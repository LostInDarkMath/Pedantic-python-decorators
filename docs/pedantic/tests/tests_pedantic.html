<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pedantic.tests.tests_pedantic API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pedantic.tests.tests_pedantic</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os.path
import sys
import types
import typing
import unittest
from datetime import datetime, date
from functools import wraps
from io import BytesIO, StringIO
from typing import List, Tuple, Callable, Any, Optional, Union, Dict, Set, FrozenSet, NewType, TypeVar, Sequence, \
    AbstractSet, Iterator, NamedTuple, Collection, Type, Generator, Generic, BinaryIO, TextIO, Iterable, Container, \
    NoReturn, ClassVar
from enum import Enum, IntEnum

from pedantic import pedantic_class
from pedantic.exceptions import PedanticTypeCheckException, PedanticException, PedanticCallWithArgsException, \
    PedanticTypeVarMismatchException
from pedantic.decorators.fn_deco_pedantic import pedantic

TEST_FILE = &#39;test.txt&#39;


class Parent:
    pass


class Child(Parent):
    def method(self, a: int):
        pass


class TestDecoratorRequireKwargsAndTypeCheck(unittest.TestCase):
    def tearDown(self) -&gt; None:
        if os.path.isfile(TEST_FILE):
            os.remove(TEST_FILE)

    def test_no_kwargs(self):
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; int:
            return n + m + i

        with self.assertRaises(expected_exception=PedanticCallWithArgsException):
            calc(42, 40, 38)
        with self.assertRaises(expected_exception=PedanticCallWithArgsException):
            calc(42, m=40, i=38)
        calc(n=42, m=40, i=38)

    def test_nested_type_hints_1(self):
        @pedantic
        def calc(n: int) -&gt; List[List[float]]:
            return [0.0 * n]

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42)

    def test_nested_type_hints_1_corrected(self):
        @pedantic
        def calc(n: int) -&gt; List[List[float]]:
            return [[0.0 * n]]

        calc(n=42)

    def test_nested_type_hints_2(self):
        &#34;&#34;&#34;Problem here: int != float&#34;&#34;&#34;
        @pedantic
        def calc(n: int) -&gt; List[Tuple[float, str]]:
            return [(n, str(n))]

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42)

    def test_nested_type_hints_2_corrected(self):
        @pedantic
        def calc(n: int) -&gt; List[Tuple[int, str]]:
            return [(n, str(n))]

        @pedantic
        def calc_2(n: float) -&gt; List[Tuple[float, str]]:
            return [(n, str(n))]

        calc(n=42)
        calc_2(n=42.0)

    def test_nested_type_hints_3(self):
        &#34;&#34;&#34;Problem here: inner function actually returns Tuple[int, str]&#34;&#34;&#34;
        @pedantic
        def calc(n: int) -&gt; Callable[[int, float], Tuple[float, str]]:
            @pedantic
            def f(x: int, y: float) -&gt; Tuple[float, str]:
                return n * x, str(y)
            return f

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42)(x=3, y=3.14)

    def test_nested_type_hints_3_corrected(self):
        @pedantic
        def calc(n: int) -&gt; Callable[[int, float], Tuple[int, str]]:
            @pedantic
            def f(x: int, y: float) -&gt; Tuple[int, str]:
                return n * x, str(y)

            return f

        calc(n=42)(x=3, y=3.14)

    def test_nested_type_hints_4(self):
        &#34;&#34;&#34;Problem here: return type is actually float&#34;&#34;&#34;
        @pedantic
        def calc(n: List[List[float]]) -&gt; int:
            return n[0][0]

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=[[42.0]])

    def test_nested_type_hints_corrected(self):
        @pedantic
        def calc(n: List[List[float]]) -&gt; int:
            return int(n[0][0])

        calc(n=[[42.0]])

    def test_nested_type_hints_5(self):
        &#34;&#34;&#34;Problem here: Tuple[float, str] != Tuple[float, float]&#34;&#34;&#34;

        @pedantic
        def calc(n: int) -&gt; Callable[[int, float], Tuple[float, str]]:
            @pedantic
            def f(x: int, y: float) -&gt; Tuple[float, float]:
                return n * float(x), y
            return f

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42)

    def test_nested_type_hints_5_corrected(self):
        @pedantic
        def calc(n: int) -&gt; Callable[[int, float], Tuple[float, float]]:
            @pedantic
            def f(x: int, y: float) -&gt; Tuple[float, float]:
                return n * float(x), y
            return f

        calc(n=42)

    def test_missing_type_hint_1(self):
        &#34;&#34;&#34;Problem here: type hint for n missed&#34;&#34;&#34;
        @pedantic
        def calc(n) -&gt; float:
            return 42.0 * n

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42)

    def test_missing_type_hint_1_corrected(self):
        @pedantic
        def calc(n: int) -&gt; float:
            return 42.0 * n

        calc(n=42)

    def test_missing_type_hint_2(self):
        &#34;&#34;&#34;Problem here: Return type annotation missed&#34;&#34;&#34;
        @pedantic
        def calc(n: int):
            return &#39;Hi&#39; + str(n)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42)

    def test_missing_type_hint_2_corrected(self):
        @pedantic
        def calc(n: int) -&gt; str:
            return &#39;Hi&#39; + str(n)

        calc(n=42)

    def test_missing_type_hint_3(self):
        &#34;&#34;&#34;Problem here: type hint for i missed&#34;&#34;&#34;
        @pedantic
        def calc(n: int, m: int, i) -&gt; int:
            return n + m + i

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42, m=40, i=38)

    def test_missing_type_hint_3_corrected(self):
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; int:
            return n + m + i

        calc(n=42, m=40, i=38)

    def test_all_ok_2(self):
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; str:
            return str(n + m + i)

        calc(n=42, m=40, i=38)

    def test_all_ok_3(self):
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; None:
            str(n + m + i)

        calc(n=42, m=40, i=38)

    def test_all_ok_4(self):
        @pedantic
        def calc(n: int) -&gt; List[List[int]]:
            return [[n]]

        calc(n=42)

    def test_all_ok_5(self):
        @pedantic
        def calc(n: int) -&gt; List[Tuple[float, str]]:
            return [(float(n), str(n))]

        calc(n=42)

    def test_all_ok_6(self):
        @pedantic
        def calc(n: int) -&gt; Callable[[int, float], Tuple[float, str]]:
            @pedantic
            def f(x: int, y: float) -&gt; Tuple[float, str]:
                return n * float(x), str(y)
            return f

        calc(n=42)(x=72, y=3.14)

    def test_all_ok_7(self):
        @pedantic
        def calc(n: List[List[float]]) -&gt; Any:
            return n[0][0]

        calc(n=[[42.0]])

    def test_all_ok_8(self):
        @pedantic
        def calc(n: int) -&gt; Callable[[int, float], Tuple[float, str]]:
            @pedantic
            def f(x: int, y: float) -&gt; Tuple[float, str]:
                return n * float(x), str(y)

            return f

        calc(n=42)(x=3, y=3.14)

    def test_wrong_type_hint_1(self):
        &#34;&#34;&#34;Problem here: str != int&#34;&#34;&#34;
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; str:
            return n + m + i

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42, m=40, i=38)

    def test_wrong_type_hint_1_corrected(self):
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; str:
            return str(n + m + i)

        calc(n=42, m=40, i=38)

    def test_wrong_type_hint_2(self):
        &#34;&#34;&#34;Problem here: str != int&#34;&#34;&#34;
        @pedantic
        def calc(n: int, m: int, i: str) -&gt; int:
            return n + m + i

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42, m=40, i=38)

    def test_wrong_type_hint_2_corrected(self):
        @pedantic
        def calc(n: int, m: int, i: str) -&gt; int:
            return n + m + int(i)

        calc(n=42, m=40, i=&#39;38&#39;)

    def test_wrong_type_hint_3(self):
        &#34;&#34;&#34;Problem here: None != int&#34;&#34;&#34;
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; None:
            return n + m + i

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42, m=40, i=38)

    def test_wrong_type_hint_corrected(self):
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; None:
            print(n + m + i)

        calc(n=42, m=40, i=38)

    def test_wrong_type_hint_4(self):
        &#34;&#34;&#34;Problem here: None != int&#34;&#34;&#34;
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; int:
            print(n + m + i)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42, m=40, i=38)

    def test_wrong_type_hint_4_corrected(self):
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; int:
            return n + m + i

        calc(n=42, m=40, i=38)

    def test_none_1(self):
        &#34;&#34;&#34;Problem here: None is not accepted&#34;&#34;&#34;
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; int:
            return n + m + i

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42, m=40, i=None)

    def test_none_2(self):
        @pedantic
        def calc(n: int, m: int, i: Optional[int]) -&gt; int:
            return n + m + i if i is not None else n + m

        calc(n=42, m=40, i=None)

    def test_none_3(self):
        @pedantic
        def calc(n: int, m: int, i: Union[int, None]) -&gt; int:
            return n + m + i if i is not None else n + m

        calc(n=42, m=40, i=None)

    def test_none_4(self):
        &#34;&#34;&#34;Problem here: function may return None&#34;&#34;&#34;
        @pedantic
        def calc(n: int, m: int, i: Union[int, None]) -&gt; int:
            return n + m + i if i is not None else None

        calc(n=42, m=40, i=42)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42, m=40, i=None)

    def test_none_5(self):
        @pedantic
        def calc(n: int, m: int, i: Union[int, None]) -&gt; Optional[int]:
            return n + m + i if i is not None else None

        calc(n=42, m=40, i=None)

    def test_inheritance_1(self):
        class MyClassA:
            pass

        class MyClassB(MyClassA):
            pass

        @pedantic
        def calc(a: MyClassA) -&gt; str:
            return str(a)

        calc(a=MyClassA())
        calc(a=MyClassB())

    def test_inheritance_2(self):
        &#34;&#34;&#34;Problem here: A is not a subtype of B&#34;&#34;&#34;
        class MyClassA:
            pass

        class MyClassB(MyClassA):
            pass

        @pedantic
        def calc(a: MyClassB) -&gt; str:
            return str(a)

        calc(a=MyClassB())
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(a=MyClassA())

    def test_instance_method_1(self):
        class MyClassA:
            @pedantic
            def calc(self, i: int) -&gt; str:
                return str(i)

        a = MyClassA()
        a.calc(i=42)

    def test_instance_method_2(self):
        &#34;&#34;&#34;Problem here: &#39;i&#39; has no type annotation&#34;&#34;&#34;
        class MyClassA:
            @pedantic
            def calc(self, i) -&gt; str:
                return str(i)

        a = MyClassA()
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            a.calc(i=42)

    def test_instance_method_2_corrected(self):
        class MyClassA:
            @pedantic
            def calc(self, i: int) -&gt; str:
                return str(i)

        a = MyClassA()
        a.calc(i=42)

    def test_instance_method_int_is_not_float(self):
        class MyClassA:
            @pedantic
            def calc(self, i: float) -&gt; str:
                return str(i)

        a = MyClassA()
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            a.calc(i=42)

    def test_instance_method_3_corrected(self):
        class MyClassA:
            @pedantic
            def calc(self, i: float) -&gt; str:
                return str(i)

        a = MyClassA()
        a.calc(i=42.0)

    def test_instance_method_no_kwargs(self):
        class MyClassA:
            @pedantic
            def calc(self, i: int) -&gt; str:
                return str(i)

        a = MyClassA()
        with self.assertRaises(expected_exception=PedanticCallWithArgsException):
            a.calc(42)

    def test_instance_method_5(self):
        &#34;&#34;&#34;Problem here: instance methods is not called with kwargs&#34;&#34;&#34;
        class MyClassA:
            @pedantic
            def calc(self, i: int) -&gt; str:
                return str(i)

        a = MyClassA()
        a.calc(i=42)

    def test_lambda_1(self):
        @pedantic
        def calc(i: float) -&gt; Callable[[float], str]:
            return lambda x: str(x * i)

        calc(i=42.0)(10.0)

    def test_lambda_3(self):
        @pedantic
        def calc(i: float) -&gt; Callable[[float], str]:
            def res(x: float) -&gt; str:
                return str(x * i)
            return res

        calc(i=42.0)(10.0)

    def test_lambda_int_is_not_float(self):
        @pedantic
        def calc(i: float) -&gt; Callable[[float], str]:
            def res(x: int) -&gt; str:
                return str(x * i)
            return res

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(i=42.0)(x=10)

    def test_lambda_4_almost_corrected(self):
        &#34;&#34;&#34;Problem here: float != str&#34;&#34;&#34;
        @pedantic
        def calc(i: float) -&gt; Callable[[float], str]:
            @pedantic
            def res(x: int) -&gt; str:
                return str(x * i)
            return res

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(i=42.0)(x=10)

    def test_lambda_4_almost_corrected_2(self):
        @pedantic
        def calc(i: float) -&gt; Callable[[int], str]:
            @pedantic
            def res(x: int) -&gt; str:
                return str(x * i)
            return res

        calc(i=42.0)(x=10)

    def test_lambda_5(self):
        &#34;&#34;&#34;Problem here: float != int&#34;&#34;&#34;
        @pedantic
        def calc(i: float) -&gt; Callable[[float], str]:
            @pedantic
            def res(x: float) -&gt; str:
                return str(x * i)
            return res

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(i=42.0)(x=10)

    def test_lambda_corrected(self):
        @pedantic
        def calc(i: float) -&gt; Callable[[float], str]:
            @pedantic
            def res(x: float) -&gt; str:
                return str(x * i)

            return res

        calc(i=42.0)(x=10.0)

    def test_tuple_without_type_args(self):
        @pedantic
        def calc(i: Tuple) -&gt; str:
            return str(i)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(i=(42.0, 43, &#39;hi&#39;))

    def test_tuple_without_args_corrected(self):
        @pedantic
        def calc(i: Tuple[Any, ...]) -&gt; str:
            return str(i)

        calc(i=(42.0, 43, &#39;hi&#39;))

    def test_callable_without_type_args(self):
        @pedantic
        def calc(i: Callable) -&gt; str:
            return str(i(&#39; you&#39;))

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(i=lambda x: (42.0, 43, &#39;hi&#39;, x))

    def test_callable_without_args_correct_with_lambdas(self):
        @pedantic
        def calc(i: Callable[[Any], Tuple[Any, ...]]) -&gt; str:
            return str(i(x=&#39; you&#39;))

        calc(i=lambda x: (42.0, 43, &#39;hi&#39;, x))

    def test_callable_without_args_corrected(self):
        @pedantic
        def calc(i: Callable[[Any], Tuple[Any, ...]]) -&gt; str:
            return str(i(x=&#39; you&#39;))

        @pedantic
        def arg(x: Any) -&gt; Tuple[Any, ...]:
            return 42.0, 43, &#39;hi&#39;, x
        calc(i=arg)

    def test_list_without_args(self):
        @pedantic
        def calc(i: List) -&gt; Any:
            return [i]

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(i=[42.0, 43, &#39;hi&#39;])

    def test_list_without_args_corrected(self):
        @pedantic
        def calc(i: List[Any]) -&gt; List[List[Any]]:
            return [i]

        calc(i=[42.0, 43, &#39;hi&#39;])

    def test_ellipsis_in_callable_1(self):
        @pedantic
        def calc(i: Callable[..., int]) -&gt; int:
            return i()

        @pedantic
        def call() -&gt; int:
            return 42

        calc(i=call)

    def test_ellipsis_in_callable_2(self):
        @pedantic
        def calc(i: Callable[..., int]) -&gt; int:
            return i(x=3.14, y=5)

        @pedantic
        def call(x: float, y: int) -&gt; int:
            return 42

        calc(i=call)

    def test_ellipsis_in_callable_3(self):
        &#34;&#34;&#34;Problem here: call to &#34;call&#34; misses one argument&#34;&#34;&#34;
        @pedantic
        def calc(i: Callable[..., int]) -&gt; int:
            return i(x=3.14)

        @pedantic
        def call(x: float, y: int) -&gt; int:
            return 42

        with self.assertRaises(expected_exception=PedanticException):
            calc(i=call)

    def test_optional_args_1(self):
        @pedantic
        def calc(a: int, b: int = 42) -&gt; int:
            return a + b

        calc(a=2)

    def test_optional_args_2(self):
        @pedantic
        def calc(a: int = 3, b: int = 42, c: float = 5.0) -&gt; float:
            return a + b + c

        calc()
        calc(a=1)
        calc(b=1)
        calc(c=1.0)
        calc(a=1, b=1)
        calc(a=1, c=1.0)
        calc(b=1, c=1.0)
        calc(a=1, b=1, c=1.0)

    def test_optional_args_3(self):
        &#34;&#34;&#34;Problem here: optional argument c: 5 is not a float&#34;&#34;&#34;
        @pedantic
        def calc(a: int = 3, b: int = 42, c: float = 5) -&gt; float:
            return a + b + c

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc()

    def test_optional_args_3_corrected(self):
        @pedantic
        def calc(a: int = 3, b: int = 42, c: float = 5.0) -&gt; float:
            return a + b + c

        calc()

    def test_optional_args_4(self):
        class MyClass:
            @pedantic
            def foo(self, a: int, b: Optional[int] = 1) -&gt; int:
                return a + b

        my_class = MyClass()
        my_class.foo(a=10)

    def test_optional_args_5(self):
        @pedantic
        def calc(d: Optional[Dict[int, int]] = None) -&gt; Optional[int]:
            if d is None:
                return None
            return sum(d.keys())

        calc(d=None)
        calc()
        calc(d={42: 3})

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(d={42: 3.14})

    def test_optional_args_6(self):
        &#34;&#34;&#34;&#34;Problem here: str != int&#34;&#34;&#34;
        @pedantic
        def calc(d: int = 42) -&gt; int:
            return int(d)

        calc(d=99999)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(d=&#39;999999&#39;)

    def test_enum_1(self):
        &#34;&#34;&#34;Problem here: Type hint for &#39;a&#39; should be MyEnum instead of MyEnum.GAMMA&#34;&#34;&#34;
        class MyEnum(Enum):
            ALPHA = &#39;startEvent&#39;
            BETA = &#39;task&#39;
            GAMMA = &#39;sequenceFlow&#39;

        class MyClass:
            @pedantic
            def operation(self, a: MyEnum.GAMMA) -&gt; None:
                print(a)

        m = MyClass()
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            m.operation(a=MyEnum.GAMMA)

    def test_enum_1_corrected(self):
        class MyEnum(Enum):
            ALPHA = &#39;startEvent&#39;
            BETA = &#39;task&#39;
            GAMMA = &#39;sequenceFlow&#39;

        @pedantic
        def operation(a: MyEnum) -&gt; None:
            print(a)

        operation(a=MyEnum.GAMMA)

    def test_sloppy_types_dict(self):
        @pedantic
        def operation(d: dict) -&gt; int:
            return len(d.keys())

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d={1: 1, 2: 2})

    def test_sloppy_types_dict_almost_corrected_no_type_args(self):
        @pedantic
        def operation(d: Dict) -&gt; int:
            return len(d.keys())

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d={1: 1, 2: 2})

    def test_sloppy_types_dict_corrected(self):
        @pedantic
        def operation(d: Dict[int, int]) -&gt; int:
            return len(d.keys())

        operation(d={1: 1, 2: 2})

    def test_sloppy_types_list(self):
        @pedantic
        def operation(d: list) -&gt; int:
            return len(d)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d=[1, 2, 3, 4])

    def test_sloppy_types_list_almost_corrected_no_type_args(self):
        @pedantic
        def operation(d: List) -&gt; int:
            return len(d)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d=[1, 2, 3, 4])

    def test_sloppy_types_list_corrected(self):
        @pedantic
        def operation(d: List[int]) -&gt; int:
            return len(d)

        operation(d=[1, 2, 3, 4])

    def test_sloppy_types_tuple(self):
        @pedantic
        def operation(d: tuple) -&gt; int:
            return len(d)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d=(1, 2, 3))

    def test_sloppy_types_tuple_almost_corrected_no_type_args(self):
        @pedantic
        def operation(d: Tuple) -&gt; int:
            return len(d)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d=(1, 2, 3))

    def test_sloppy_types_tuple_corrected(self):
        @pedantic
        def operation(d: Tuple[int, int, int]) -&gt; int:
            return len(d)

        operation(d=(1, 2, 3))

    def test_sloppy_types_set(self):
        @pedantic
        def operation(d: set) -&gt; int:
            return len(d)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d={1, 2, 3})

    def test_sloppy_types_set_almost_corrected_to_type_args(self):
        @pedantic
        def operation(d: Set) -&gt; int:
            return len(d)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d={1, 2, 3})

    def test_sloppy_types_set_corrected(self):
        @pedantic
        def operation(d: Set[int]) -&gt; int:
            return len(d)

        operation(d={1, 2, 3})

    def test_sloppy_types_frozenset(self):
        @pedantic
        def operation(d: frozenset) -&gt; int:
            return len(d)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d=frozenset({1, 2, 3}))

    def test_sloppy_types_frozenset_almost_corrected_no_type_args(self):
        @pedantic
        def operation(d: FrozenSet) -&gt; int:
            return len(d)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d=frozenset({1, 2, 3}))

    def test_sloppy_types_frozenset_corrected(self):
        @pedantic
        def operation(d: FrozenSet[int]) -&gt; int:
            return len(d)

        operation(d=frozenset({1, 2, 3}))

    def test_type_list_but_got_tuple(self):
        @pedantic
        def calc(ls: List[Any]) -&gt; int:
            return len(ls)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(ls=(1, 2, 3))

    def test_type_list_corrected(self):
        @pedantic
        def calc(ls: Tuple[Any, ...]) -&gt; int:
            return len(ls)

        calc(ls=(1, 2, 3))

    def test_any(self):
        @pedantic
        def calc(ls: List[Any]) -&gt; Dict[int, Any]:
            return {i: ls[i] for i in range(0, len(ls))}

        calc(ls=[1, 2, 3])
        calc(ls=[1.11, 2.0, 3.0])
        calc(ls=[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;])
        calc(ls=[10.5, &#39;2&#39;, (3, 4, 5)])

    def test_aliases(self):
        Vector = List[float]

        @pedantic
        def scale(scalar: float, vector: Vector) -&gt; Vector:
            return [scalar * num for num in vector]

        scale(scalar=2.0, vector=[1.0, -4.2, 5.4])

    def test_new_type(self):
        UserId = NewType(&#39;UserId&#39;, int)

        @pedantic
        def get_user_name(user_id: UserId) -&gt; str:
            return str(user_id)

        some_id = UserId(524313)
        get_user_name(user_id=some_id)

        # the following would be desirable but impossible to check at runtime:
        # with self.assertRaises(expected_exception=AssertionError):
        #     get_user_name(user_id=-1)

    def test_list_of_new_type(self):
        UserId = NewType(&#39;UserId&#39;, int)

        @pedantic
        def get_user_name(user_ids: List[UserId]) -&gt; str:
            return str(user_ids)

        get_user_name(user_ids=[UserId(524313), UserId(42)])
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            get_user_name(user_ids=[UserId(524313), UserId(42), 430.0])

    def test_callable_no_args(self):
        @pedantic
        def f(g: Callable[[], str]) -&gt; str:
            return g()

        @pedantic
        def greetings() -&gt; str:
            return &#39;hello world&#39;

        f(g=greetings)

    def test_type_var(self):
        T = TypeVar(&#39;T&#39;)

        @pedantic
        def first(ls: List[T]) -&gt; T:
            return ls[0]

        first(ls=[1, 2, 3])

    def test_type_var_wrong(self):
        T = TypeVar(&#39;T&#39;)

        @pedantic
        def first(ls: List[T]) -&gt; T:
            return str(ls[0])

        with self.assertRaises(expected_exception=PedanticTypeVarMismatchException):
            first(ls=[1, 2, 3])

    def test_type_var_wrong_sequence(self):
        T = TypeVar(&#39;T&#39;)

        @pedantic
        def first(ls: Sequence[T]) -&gt; T:
            return str(ls[0])

        with self.assertRaises(expected_exception=PedanticTypeVarMismatchException):
            first(ls=[1, 2, 3])

    def test_double_pedantic(self):
        @pedantic
        @pedantic
        def f(x: int, y: float) -&gt; Tuple[float, str]:
            return float(x), str(y)

        f(x=5, y=3.14)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            f(x=5.0, y=3.14)
        with self.assertRaises(expected_exception=PedanticCallWithArgsException):
            f(5, 3.14)

    def test_args_kwargs(self):
        @pedantic
        def some_method(a: int = 0, b: float = 0.0) -&gt; float:
            return a * b

        @pedantic
        def wrapper_method(*args: Union[int, float], **kwargs: Union[int, float]) -&gt; float:
            return some_method(*args, **kwargs)

        some_method()
        with self.assertRaises(expected_exception=PedanticCallWithArgsException):
            some_method(3, 3.0)
        some_method(a=3, b=3.0)
        wrapper_method()
        with self.assertRaises(expected_exception=PedanticCallWithArgsException):
            wrapper_method(3, 3.0)
        wrapper_method(a=3, b=3.0)

    def test_args_kwargs_no_type_hint(self):
        @pedantic
        def method_no_type_hint(*args, **kwargs) -&gt; None:
            print(args)
            print(kwargs)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            method_no_type_hint(a=3, b=3.0)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            method_no_type_hint()

    def test_args_kwargs_wrong_type_hint(self):
        &#34;&#34;&#34;See: https://www.python.org/dev/peps/pep-0484/#arbitrary-argument-lists-and-default-argument-values&#34;&#34;&#34;
        @pedantic
        def wrapper_method(*args: str, **kwargs: str) -&gt; None:
            print(args)
            print(kwargs)

        wrapper_method()
        wrapper_method(&#39;hi&#39;, &#39;you&#39;, &#39;:)&#39;)
        wrapper_method(a=&#39;hi&#39;, b=&#39;you&#39;, c=&#39;:)&#39;)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            wrapper_method(&#39;hi&#39;, &#39;you&#39;, &#39;:)&#39;, 7)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            wrapper_method(3, 3.0)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            wrapper_method(a=3, b=3.0)

    def test_additional_kwargs(self):
        @pedantic
        def some_method(a: int, b: float = 0.0, **kwargs: int) -&gt; float:
            return sum([a, b])

        some_method(a=5)
        some_method(a=5, b=0.1)
        some_method(a=5, b=0.1, c=4)
        some_method(a=5, b=0.1, c=4, d=5, e=6)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            some_method(a=5, b=0.1, c=4, d=5.0, e=6)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            some_method(a=5.0, b=0.1, c=4, d=5, e=6)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            some_method(a=5, b=0, c=4, d=5, e=6)

    def test_args_kwargs_different_types(self):
        @pedantic
        def foo(*args: str, **kwds: int) -&gt; None:
            print(args)
            print(kwds)

        foo(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)
        foo(x=1, y=2)
        foo(&#39;&#39;, z=0)

    def test_pedantic_on_class(self):
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            @pedantic
            class MyClass:
                pass
            MyClass()

    def test_is_subtype_tuple(self):
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            @pedantic
            def foo() -&gt; Callable[[Tuple[float, str]], Tuple[int]]:
                def bar(a: Tuple[float]) -&gt; Tuple[int]:
                    return len(a[1]) + int(a[0]),
                return bar
            foo()

    def test_is_subtype_tuple_corrected(self):
        @pedantic
        def foo() -&gt; Callable[[Tuple[float, str]], Tuple[int]]:
            def bar(a: Tuple[float, str]) -&gt; Tuple[int]:
                return len(a[1]) + int(a[0]),
            return bar
        foo()

    def test_forward_ref(self):
        class Conversation:
            pass

        @pedantic
        def get_conversations() -&gt; List[&#39;Conversation&#39;]:
            return [Conversation(), Conversation()]

        get_conversations()

    def test_alternative_list_type_hint(self):
        @pedantic
        def _is_digit_in_int(digit: [int], num: int) -&gt; bool:
            num_str = str(num)
            for i in num_str:
                if int(i) == digit:
                    return True
            return False

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            _is_digit_in_int(digit=4, num=42)

    def test_callable_with_union_return(self):
        class MyClass:
            pass

        @pedantic
        def admin_required(func: Callable[..., Union[str, MyClass]]) -&gt; Callable[..., Union[str, MyClass]]:
            @wraps(func)
            def decorated_function(*args, **kwargs):
                return func(*args, **kwargs)
            return decorated_function

        @admin_required
        @pedantic
        def get_server_info() -&gt; str:
            return &#39;info&#39;

        get_server_info()

    def test_pedantic(self):
        @pedantic
        def foo(a: int, b: str) -&gt; str:
            return &#39;abc&#39;

        self.assertEqual(&#39;abc&#39;, foo(a=4, b=&#39;abc&#39;))

    def test_pedantic_always(self):
        @pedantic
        def foo(a: int, b: str) -&gt; str:
            return &#39;abc&#39;

        self.assertEqual(&#39;abc&#39;, foo(a=4, b=&#39;abc&#39;))

    def test_pedantic_arguments_fail(self):
        @pedantic
        def foo(a: int, b: str) -&gt; str:
            return &#39;abc&#39;

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            foo(a=4, b=5)

    def test_pedantic_return_type_fail(self):
        @pedantic
        def foo(a: int, b: str) -&gt; str:
            return 6

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            foo(a=4, b=&#39;abc&#39;)

    def test_return_type_none(self):
        @pedantic
        def foo() -&gt; None:
            return &#39;a&#39;
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            foo()

    def test_marco(self):
        @pedantic_class
        class A:
            def __init__(self, val: int) -&gt; None:
                self.val = val

            def __eq__(self, other: &#39;A&#39;) -&gt; bool:  # other: A and all subclasses
                return self.val == other.val

        @pedantic_class
        class B(A):
            def __init__(self, val: int) -&gt; None:
                super().__init__(val=val)

        @pedantic_class
        class C(A):
            def __init__(self, val: int) -&gt; None:
                super().__init__(val=val)

        a = A(val=42)
        b = B(val=42)
        c = C(val=42)

        assert a == b  # works
        assert a == c  # works
        assert b == c  # error

    def test_date_datetime(self):
        @pedantic
        def foo(a: datetime, b: date) -&gt; None:
            pass

        foo(a=datetime(1995, 2, 5), b=date(1987, 8, 7))
        foo(a=datetime(1995, 2, 5), b=datetime(1987, 8, 7))

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            foo(a=date(1995, 2, 5), b=date(1987, 8, 7))

    def test_any_type(self):
        @pedantic
        def foo(a: Any) -&gt; None:
            pass

        foo(a=&#39;aa&#39;)

    def test_callable_exact_arg_count(self):
        @pedantic
        def foo(a: Callable[[int, str], int]) -&gt; None:
            pass

        def some_callable(x: int, y: str) -&gt; int:
            pass

        foo(a=some_callable)

    def test_callable_bad_type(self):
        @pedantic
        def foo(a: Callable[..., int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=5)

    def test_callable_too_few_arguments(self):
        @pedantic
        def foo(a: Callable[[int, str], int]) -&gt; None:
            pass

        def some_callable(x: int) -&gt; int:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=some_callable)

    def test_callable_mandatory_kwonlyargs(self):
        @pedantic
        def foo(a: Callable[[int, str], int]) -&gt; None:
            pass

        def some_callable(x: int, y: str, *, z: float, bar: str) -&gt; int:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=some_callable)

    def test_callable_class(self):
        &#34;&#34;&#34;
        Test that passing a class as a callable does not count the &#34;self&#34; argument &#34;a&#34;gainst the
        ones declared in the Callable specification.

        &#34;&#34;&#34;
        @pedantic
        def foo(a: Callable[[int, str], Any]) -&gt; None:
            pass

        class SomeClass:
            def __init__(self, x: int, y: str):
                pass

        foo(a=SomeClass)

    def test_callable_plain(self):
        @pedantic
        def foo(a: Callable[..., Any]) -&gt; None:
            pass

        def callback(a):
            pass

        foo(a=callback)

    def test_callable_bound_method(self):
        @pedantic
        def foo(callback: Callable[[int], Any]) -&gt; None:
            pass

        foo(callback=Child().method)

    def test_callable_defaults(self):
        &#34;&#34;&#34;
        Test that a callable having &#34;too many&#34; arguments don&#39;t raise an error if the extra
        arguments have default values.

        &#34;&#34;&#34;
        @pedantic
        def foo(callback: Callable[[int, str], Any]) -&gt; None:
            pass

        def some_callable(x: int, y: str, z: float = 1.2) -&gt; int:
            pass

        foo(callback=some_callable)

    def test_callable_builtin(self):
        @pedantic
        def foo(callback: types.BuiltinFunctionType) -&gt; None:
            pass

        foo(callback=[].append)

    def test_dict_bad_type(self):
        @pedantic
        def foo(a: Dict[str, int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=5)

    def test_dict_bad_key_type(self):
        @pedantic
        def foo(a: Dict[str, int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a={1: 2})

    def test_dict_bad_value_type(self):
        @pedantic
        def foo(a: Dict[str, int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a={&#39;x&#39;: &#39;a&#39;})

    def test_list_bad_type(self):
        @pedantic
        def foo(a: List[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=5)

    def test_list_bad_element(self):
        @pedantic
        def foo(a: List[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=[1, 2, &#39;bb&#39;])

    def test_sequence_bad_type(self):
        @pedantic
        def foo(a: Sequence[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=5)

    def test_sequence_bad_element(self):
        @pedantic
        def foo(a: Sequence[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=[1, 2, &#39;bb&#39;])

    def test_abstractset_custom_type(self):
        T = TypeVar(&#39;T&#39;)

        @pedantic_class
        class DummySet(AbstractSet[T]):
            def __contains__(self, x: object) -&gt; bool:
                return x == 1

            def __len__(self) -&gt; T:
                return 1

            def __iter__(self) -&gt; Iterator[T]:
                yield 1

        @pedantic
        def foo(a: AbstractSet[int]) -&gt; None:
            pass

        foo(a=DummySet[int]())

    def test_abstractset_bad_type(self):
        @pedantic
        def foo(a: AbstractSet[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=5)

    def test_set_bad_type(self):
        @pedantic
        def foo(a: Set[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=5)

    def test_abstractset_bad_element(self):
        @pedantic
        def foo(a: AbstractSet[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a={1, 2, &#39;bb&#39;})

    def test_set_bad_element(self):
        @pedantic
        def foo(a: Set[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a={1, 2, &#39;bb&#39;})

    def test_tuple_bad_type(self):
        @pedantic
        def foo(a: Tuple[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=5)

    def test_tuple_too_many_elements(self):
        @pedantic
        def foo(a: Tuple[int, str]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=(1, &#39;aa&#39;, 2))

    def test_tuple_too_few_elements(self):
        @pedantic
        def foo(a: Tuple[int, str]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=(1,))

    def test_tuple_bad_element(self):
        @pedantic
        def foo(a: Tuple[int, str]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=(1, 2))

    def test_tuple_ellipsis_bad_element(self):
        @pedantic
        def foo(a: Tuple[int, ...]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=(1, 2, &#39;blah&#39;))

    def test_namedtuple(self):
        Employee = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])

        @pedantic
        def foo(bar: Employee) -&gt; None:
            print(bar)

        foo(bar=Employee(&#39;bob&#39;, 1))

    def test_namedtuple_key_mismatch(self):
        Employee1 = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])
        Employee2 = NamedTuple(&#39;Employee&#39;, [(&#39;firstname&#39;, str), (&#39;id&#39;, int)])

        @pedantic
        def foo(bar: Employee1) -&gt; None:
            print(bar)

        with self.assertRaises(PedanticTypeCheckException):
            foo(bar=Employee2(&#39;bob&#39;, 1))

    def test_namedtuple_type_mismatch(self):
        Employee = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])

        @pedantic
        def foo(bar: Employee) -&gt; None:
            print(bar)

        with self.assertRaises(PedanticTypeCheckException):
            foo(bar=(&#39;bob&#39;, 1))

    def test_namedtuple_huge_type_mismatch(self):
        Employee = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])

        @pedantic
        def foo(bar: int) -&gt; None:
            print(bar)

        with self.assertRaises(PedanticTypeCheckException):
            foo(bar=foo(bar=Employee(&#39;bob&#39;, 1)))

    def test_namedtuple_wrong_field_type(self):
        Employee = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])

        @pedantic
        def foo(bar: Employee) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(bar=Employee(2, 1))

    def test_union(self):
        @pedantic
        def foo(a: Union[str, int]) -&gt; None:
            pass

        for value in [6, &#39;xa&#39;]:
            foo(a=value)

    def test_union_typing_type(self):
        @pedantic
        def foo(a: Union[str, Collection]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=1)

    def test_union_fail(self):
        @pedantic
        def foo(a: Union[str, int]) -&gt; None:
            pass

        for value in [5.6, b&#39;xa&#39;]:
            with self.assertRaises(PedanticTypeCheckException):
                foo(a=value)

    def test_type_var_constraints(self):
        T = TypeVar(&#39;T&#39;, int, str)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        for values in [
            {&#39;a&#39;: 6, &#39;b&#39;: 7},
            {&#39;a&#39;: &#39;aa&#39;, &#39;b&#39;: &#34;bb&#34;},
        ]:
            foo(**values)

    def test_type_var_constraints_fail_typing_type(self):
        T = TypeVar(&#39;T&#39;, int, Collection)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=&#39;aa&#39;, b=&#39;bb&#39;)

    def test_typevar_constraints_fail(self):
        T = TypeVar(&#39;T&#39;, int, str)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=2.5, b=&#39;aa&#39;)

    def test_typevar_bound(self):
        T = TypeVar(&#39;T&#39;, bound=Parent)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        foo(a=Child(), b=Child())

    def test_type_var_bound_fail(self):
        T = TypeVar(&#39;T&#39;, bound=Child)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=Parent(), b=Parent())

    def test_type_var_invariant_fail(self):
        T = TypeVar(&#39;T&#39;, int, str)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=2, b=3.6)

    def test_type_var_covariant(self):
        T = TypeVar(&#39;T&#39;, covariant=True)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        foo(a=Parent(), b=Child())

    def test_type_var_covariant_fail(self):
        T = TypeVar(&#39;T&#39;, covariant=True)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeVarMismatchException):
            foo(a=Child(), b=Parent())

    def test_type_var_contravariant(self):
        T = TypeVar(&#39;T&#39;, contravariant=True)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        foo(a=Child(), b=Parent())

    def test_type_var_contravariant_fail(self):
        T = TypeVar(&#39;T&#39;, contravariant=True)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeVarMismatchException):
            foo(a=Parent(), b=Child())

    def test_class_bad_subclass(self):
        @pedantic
        def foo(a: Type[Child]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=Parent)

    def test_class_any(self):
        @pedantic
        def foo(a: Type[Any]) -&gt; None:
            pass

        foo(a=str)

    def test_wrapped_function(self):
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                return func(*args, **kwargs)
            return wrapper

        @pedantic
        @decorator
        def foo(a: &#39;Child&#39;) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=Parent())

    def test_mismatching_default_type(self):
        @pedantic
        def foo(a: str = 1) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo()

    def test_implicit_default_none(self):
        &#34;&#34;&#34;
        Test that if the default value is ``None``, a ``None`` argument can be passed.

        &#34;&#34;&#34;
        @pedantic
        def foo(a: Optional[str] = None) -&gt; None:
            pass

        foo()

    def test_generator_simple(self):
        &#34;&#34;&#34;Test that argument type checking works in a generator function too.&#34;&#34;&#34;
        @pedantic
        def generate(a: int) -&gt; Generator[int, int, None]:
            yield a
            yield a + 1

        gen = generate(a=1)
        next(gen)

    def test_wrapped_generator_no_return_type_annotation(self):
        &#34;&#34;&#34;Test that return type checking works in a generator function too.&#34;&#34;&#34;
        @pedantic
        def generate(a: int) -&gt; Generator[int, int, None]:
            yield a
            yield a + 1

        gen = generate(a=1)
        next(gen)

    def test_varargs(self):
        @pedantic
        def foo(*args: int) -&gt; None:
            pass

        foo(1, 2)

    def test_varargs_fail(self):
        @pedantic
        def foo(*args: int) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(1, &#39;a&#39;)

    def test_kwargs(self):
        @pedantic
        def foo(**kwargs: int) -&gt; None:
            pass

        foo(a=1, b=2)

    def test_kwargs_fail(self):
        @pedantic
        def foo(**kwargs: int) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=1, b=&#39;a&#39;)

    def test_generic(self):
        T_Foo = TypeVar(&#39;T_Foo&#39;)

        class FooGeneric(Generic[T_Foo]):
            pass

        @pedantic
        def foo(a: FooGeneric[str]) -&gt; None:
            print(a)

        foo(a=FooGeneric[str]())

    def test_newtype(self):
        myint = NewType(&#34;myint&#34;, int)

        @pedantic
        def foo(a: myint) -&gt; int:
            return 42

        assert foo(a=1) == 42

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=&#34;a&#34;)

    def test_collection(self):
        @pedantic
        def foo(a: Collection) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=True)

    def test_binary_io(self):
        @pedantic
        def foo(a: BinaryIO) -&gt; None:
            print(a)

        foo(a=BytesIO())

    def test_text_io(self):
        @pedantic
        def foo(a: TextIO) -&gt; None:
            print(a)

        foo(a=StringIO())

    def test_binary_io_fail(self):
        @pedantic
        def foo(a: TextIO) -&gt; None:
            print(a)

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=BytesIO())

    def test_text_io_fail(self):
        @pedantic
        def foo(a: BinaryIO) -&gt; None:
            print(a)

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=StringIO())

    def test_binary_io_real_file(self):
        @pedantic
        def foo(a: BinaryIO) -&gt; None:
            print(a)

        with open(file=TEST_FILE, mode=&#39;wb&#39;) as f:
            foo(a=f)

    def test_text_io_real_file(self):
        @pedantic
        def foo(a: TextIO) -&gt; None:
            print(a)

        with open(file=TEST_FILE, mode=&#39;w&#39;) as f:
            foo(a=f)

    def test_pedantic_return_type_var_fail(self):
        T = TypeVar(&#39;T&#39;, int, float)

        @pedantic
        def foo(a: T, b: T) -&gt; T:
            return &#39;a&#39;

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=4, b=2)

    def test_callable(self):
        @pedantic
        def foo_1(a: Callable[..., int]) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: Callable) -&gt; None:
            print(a)

        def some_callable() -&gt; int:
            return 4

        foo_1(a=some_callable)

        with self.assertRaises(PedanticTypeCheckException):
            foo_2(a=some_callable)

    def test_list(self):
        @pedantic
        def foo_1(a: List[int]) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: List) -&gt; None:
            print(a)

        @pedantic
        def foo_3(a: list) -&gt; None:
            print(a)

        foo_1(a=[1, 2])

        with self.assertRaises(PedanticTypeCheckException):
            foo_2(a=[1, 2])

        with self.assertRaises(PedanticTypeCheckException):
            foo_3(a=[1, 2])

    def test_dict(self):
        @pedantic
        def foo_1(a: Dict[str, int]) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: Dict) -&gt; None:
            print(a)

        @pedantic
        def foo_3(a: dict) -&gt; None:
            print(a)

        foo_1(a={&#39;x&#39;: 2})

        with self.assertRaises(PedanticTypeCheckException):
            foo_3(a={&#39;x&#39;: 2})

        with self.assertRaises(PedanticTypeCheckException):
            foo_3(a={&#39;x&#39;: 2})

    def test_sequence(self):
        @pedantic
        def foo(a: Sequence[str]) -&gt; None:
            print(a)

        for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
            foo(a=value)

    def test_sequence_no_type_args(self):
        @pedantic
        def foo(a: Sequence) -&gt; None:
            print(a)

        for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
            with self.assertRaises(PedanticTypeCheckException):
                foo(a=value)

    def test_iterable(self):
        @pedantic
        def foo(a: Iterable[str]) -&gt; None:
            print(a)

        for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
            foo(a=value)

    def test_iterable_no_type_args(self):
        @pedantic
        def foo(a: Iterable) -&gt; None:
            print(a)

        for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
            with self.assertRaises(PedanticTypeCheckException):
                foo(a=value)

    def test_container(self):
        @pedantic
        def foo(a: Container[str]) -&gt; None:
            print(a)

        for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
            foo(a=value)

    def test_container_no_type_args(self):
        @pedantic
        def foo(a: Container) -&gt; None:
            print(a)

        for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
            with self.assertRaises(PedanticTypeCheckException):
                foo(a=value)

    def test_set(self):
        @pedantic
        def foo_1(a: AbstractSet[int]) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: Set[int]) -&gt; None:
            print(a)

        for value in [set(), {6}]:
            foo_1(a=value)
            foo_2(a=value)

    def test_set_no_type_args(self):
        @pedantic
        def foo_1(a: AbstractSet) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: Set) -&gt; None:
            print(a)

        @pedantic
        def foo_3(a: set) -&gt; None:
            print(a)

        for value in [set(), {6}]:
            with self.assertRaises(PedanticTypeCheckException):
                foo_1(a=value)

            with self.assertRaises(PedanticTypeCheckException):
                foo_2(a=value)

            with self.assertRaises(PedanticTypeCheckException):
                foo_3(a=value)

    def test_tuple(self):
        @pedantic
        def foo_1(a: Tuple[int, int]) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: Tuple[int, ...]) -&gt; None:
            print(a)

        foo_1(a=(1, 2))
        foo_2(a=(1, 2))

    def test_tuple_no_type_args(self):
        @pedantic
        def foo_1(a: Tuple) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: tuple) -&gt; None:
            print(a)

        with self.assertRaises(PedanticTypeCheckException):
            foo_1(a=(1, 2))

        with self.assertRaises(PedanticTypeCheckException):
            foo_2(a=(1, 2))

    def test_empty_tuple(self):
        @pedantic
        def foo(a: Tuple[()]) -&gt; None:
            print(a)

        foo(a=())

    def test_class(self):
        @pedantic
        def foo_1(a: Type[Parent]) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: Type[TypeVar(&#39;UnboundType&#39;)]) -&gt; None:
            print(a)

        @pedantic
        def foo_3(a: Type[TypeVar(&#39;BoundType&#39;, bound=Parent)]) -&gt; None:
            print(a)

        foo_1(a=Child)
        foo_2(a=Child)
        foo_3(a=Child)

    def test_class_no_type_vars(self):
        @pedantic
        def foo_1(a: Type) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: type) -&gt; None:
            print(a)

        with self.assertRaises(PedanticTypeCheckException):
            foo_1(a=Child)

        with self.assertRaises(PedanticTypeCheckException):
            foo_2(a=Child)

    def test_class_not_a_class(self):
        @pedantic
        def foo(a: Type[Parent]) -&gt; None:
            print(a)

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=1)

    def test_complex(self):
        @pedantic
        def foo(a: complex) -&gt; None:
            print(a)

        foo(a=complex(1, 5))

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=1.0)

    def test_float(self):
        @pedantic
        def foo(a: float) -&gt; None:
            print(a)

        foo(a=1.5)

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=1)

    def test_coroutine_correct_return_type(self):
        @pedantic
        async def foo() -&gt; str:
            return &#39;foo&#39;

        coro = foo()

        with self.assertRaises(StopIteration):
            coro.send(None)

    def test_coroutine_wrong_return_type(self):
        @pedantic
        async def foo() -&gt; str:
            return 1

        coro = foo()

        with self.assertRaises(PedanticTypeCheckException):
            coro.send(None)

    def test_bytearray_bytes(self):
        @pedantic
        def foo(x: bytearray) -&gt; None:
            pass

        foo(x=bytearray([1]))

    def test_class_decorator(self):
        @pedantic_class
        class Foo:
            @staticmethod
            def staticmethod() -&gt; int:
                return &#39;foo&#39;

            @classmethod
            def classmethod(cls) -&gt; int:
                return &#39;foo&#39;

            def method(self) -&gt; int:
                return &#39;foo&#39;

        with self.assertRaises(PedanticTypeCheckException):
            Foo.staticmethod()

        with self.assertRaises(PedanticTypeCheckException):
            Foo.classmethod()

        with self.assertRaises(PedanticTypeCheckException):
            Foo().method()

    def test_generator(self):
        @pedantic
        def genfunc() -&gt; Generator[int, str, List[str]]:
            val1 = yield 2
            val2 = yield 3
            val3 = yield 4
            return [val1, val2, val3]

        gen = genfunc()

        with self.assertRaises(StopIteration):
            value = next(gen)
            while True:
                value = gen.send(str(value))
                assert isinstance(value, int)

    def test_generator_no_type_args(self):
        @pedantic
        def genfunc() -&gt; Generator:
            val1 = yield 2
            val2 = yield 3
            val3 = yield 4
            return [val1, val2, val3]

        with self.assertRaises(PedanticTypeCheckException):
            genfunc()

    def test_iterator(self):
        @pedantic
        def genfunc() -&gt; Iterator[int]:
            val1 = yield 2
            val2 = yield 3
            val3 = yield 4
            return [val1, val2, val3]

        gen = genfunc()

        with self.assertRaises(PedanticTypeCheckException):
            value = next(gen)
            while True:
                value = gen.send(str(value))
                assert isinstance(value, int)

    def test_iterator_no_type_args(self):
        @pedantic
        def genfunc() -&gt; Iterator:
            val1 = yield 2
            val2 = yield 3
            val3 = yield 4
            return [val1, val2, val3]

        with self.assertRaises(PedanticTypeCheckException):
            genfunc()

    def test_iterable_advanced(self):
        @pedantic
        def genfunc() -&gt; Iterable[int]:
            val1 = yield 2
            val2 = yield 3
            val3 = yield 4
            return [val1, val2, val3]

        gen = genfunc()

        with self.assertRaises(PedanticTypeCheckException):
            value = next(gen)
            while True:
                value = gen.send(str(value))
                assert isinstance(value, int)

    def test_iterable_advanced_no_type_args(self):
        @pedantic
        def genfunc() -&gt; Iterable:
            val1 = yield 2
            val2 = yield 3
            val3 = yield 4
            return [val1, val2, val3]

        with self.assertRaises(PedanticTypeCheckException):
            genfunc()

    def test_generator_bad_yield(self):
        @pedantic
        def genfunc_1() -&gt; Generator[int, str, None]:
            yield &#39;foo&#39;

        @pedantic
        def genfunc_2() -&gt; Iterable[int]:
            yield &#39;foo&#39;

        @pedantic
        def genfunc_3() -&gt; Iterator[int]:
            yield &#39;foo&#39;

        gen = genfunc_1()

        with self.assertRaises(PedanticTypeCheckException):
            next(gen)

        gen = genfunc_2()

        with self.assertRaises(PedanticTypeCheckException):
            next(gen)

        gen = genfunc_3()

        with self.assertRaises(PedanticTypeCheckException):
            next(gen)

    def test_generator_bad_send(self):
        @pedantic
        def genfunc() -&gt; Generator[int, str, None]:
            yield 1
            yield 2

        gen = genfunc()
        next(gen)

        with self.assertRaises(PedanticTypeCheckException):
            gen.send(2)

    def test_generator_bad_return(self):
        @pedantic
        def genfunc() -&gt; Generator[int, str, str]:
            yield 1
            return 6

        gen = genfunc()
        next(gen)

        with self.assertRaises(PedanticTypeCheckException):
            gen.send(&#39;foo&#39;)

    def test_return_generator(self):
        @pedantic
        def genfunc() -&gt; Generator[int, None, None]:
            yield 1

        @pedantic
        def foo() -&gt; Generator[int, None, None]:
            return genfunc()

        foo()

    def test_local_class(self):
        @pedantic_class
        class LocalClass:
            class Inner:
                pass

            def create_inner(self) -&gt; &#39;Inner&#39;:
                return self.Inner()

        retval = LocalClass().create_inner()
        assert isinstance(retval, LocalClass.Inner)

    def test_local_class_async(self):
        @pedantic_class
        class LocalClass:
            class Inner:
                pass

            async def create_inner(self) -&gt; &#39;Inner&#39;:
                return self.Inner()

        coro = LocalClass().create_inner()

        with self.assertRaises(StopIteration):
            coro.send(None)

    def test_callable_nonmember(self):
        class CallableClass:
            def __call__(self):
                pass

        @pedantic_class
        class LocalClass:
            some_callable = CallableClass()

    def test_inherited_class_method(self):
        @pedantic_class
        class Parent:
            @classmethod
            def foo(cls, x: str) -&gt; str:
                return cls.__name__

        @pedantic_class
        class Child(Parent):
            pass

        self.assertEqual(&#39;Parent&#39;, Child.foo(x=&#39;bar&#39;))

        with self.assertRaises(PedanticTypeCheckException):
            Child.foo(x=1)

    def test_type_var_forward_ref_bound(self):
        TBound = TypeVar(&#39;TBound&#39;, bound=&#39;Parent&#39;)

        @pedantic
        def func(x: TBound) -&gt; None:
            pass

        func(x=Parent())

        with self.assertRaises(PedanticTypeCheckException):
            func(x=&#39;foo&#39;)

    def test_noreturn(self):
        @pedantic
        def foo() -&gt; NoReturn:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo()

    def test_literal(self):
        if sys.version_info &lt; (3, 8):
            return

        from typing import Literal

        @pedantic
        def foo(a: Literal[1, True, &#39;x&#39;, b&#39;y&#39;, 404]) -&gt; None:
            print(a)

        foo(a=404)
        foo(a=True)
        foo(a=&#39;x&#39;)

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=4)

    def test_literal_union(self):
        if sys.version_info &lt; (3, 8):
            return

        from typing import Literal

        @pedantic
        def foo(a: Union[str, Literal[1, 6, 8]]) -&gt; None:
            print(a)

        foo(a=6)

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=4)

    def test_literal_illegal_value(self):
        if sys.version_info &lt; (3, 8):
            return

        from typing import Literal

        @pedantic
        def foo(a: Literal[1, 1.1]) -&gt; None:
            print(a)

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=4)

    def test_enum(self):
        with self.assertRaises(PedanticTypeCheckException):
            @pedantic_class
            class MyEnum(Enum):
                A = &#39;a&#39;

    def test_enum_aggregate(self):
        T = TypeVar(&#39;T&#39;, bound=IntEnum)

        @pedantic_class
        class EnumAggregate(Generic[T]):
            enum: ClassVar[Type[T]]

            def __init__(self, value: Union[int, str, List[T]]) -&gt; None:
                assert len(self.enum) &lt; 10

                if value == &#39;&#39;:
                    raise ValueError(f&#39;Parameter &#34;value&#34; cannot be empty!&#39;)

                if isinstance(value, list):
                    self._value = &#39;&#39;.join([str(x.value) for x in value])
                else:
                    self._value = str(value)

                self._value = &#39;&#39;.join(sorted(self._value))  # sort characters in string
                self.to_list()  # check if is valid

            def __contains__(self, item: T) -&gt; bool:
                return item in self.to_list()

            def __eq__(self, other: Union[&#39;EnumAggregate&#39;, str]) -&gt; bool:
                if isinstance(other, str):
                    return self._value == other

                return self._value == other._value

            def __str__(self) -&gt; str:
                return self._value

            def to_list(self) -&gt; List[T]:
                return [self.enum(int(character)) for character in self._value]

            @property
            def value(self) -&gt; str:
                return self._value

            @classmethod
            def all(cls) -&gt; str:
                return &#39;&#39;.join([str(x.value) for x in cls.enum])

        class Gender(IntEnum):
            MALE = 1
            FEMALE = 2
            DIVERS = 3

        @pedantic_class
        class Genders(EnumAggregate[Gender]):
            enum = Gender

        Genders(value=12)

        with self.assertRaises(PedanticTypeCheckException):
            Genders(value=Child())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pedantic.tests.tests_pedantic.Child"><code class="flex name class">
<span>class <span class="ident">Child</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Child(Parent):
    def method(self, a: int):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pedantic.tests.tests_pedantic.Parent" href="#pedantic.tests.tests_pedantic.Parent">Parent</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pedantic.tests.tests_pedantic.Child.method"><code class="name flex">
<span>def <span class="ident">method</span></span>(<span>self, a: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method(self, a: int):
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pedantic.tests.tests_pedantic.Parent"><code class="flex name class">
<span>class <span class="ident">Parent</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Parent:
    pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pedantic.tests.tests_pedantic.Child" href="#pedantic.tests.tests_pedantic.Child">Child</a></li>
</ul>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck"><code class="flex name class">
<span>class <span class="ident">TestDecoratorRequireKwargsAndTypeCheck</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestDecoratorRequireKwargsAndTypeCheck(unittest.TestCase):
    def tearDown(self) -&gt; None:
        if os.path.isfile(TEST_FILE):
            os.remove(TEST_FILE)

    def test_no_kwargs(self):
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; int:
            return n + m + i

        with self.assertRaises(expected_exception=PedanticCallWithArgsException):
            calc(42, 40, 38)
        with self.assertRaises(expected_exception=PedanticCallWithArgsException):
            calc(42, m=40, i=38)
        calc(n=42, m=40, i=38)

    def test_nested_type_hints_1(self):
        @pedantic
        def calc(n: int) -&gt; List[List[float]]:
            return [0.0 * n]

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42)

    def test_nested_type_hints_1_corrected(self):
        @pedantic
        def calc(n: int) -&gt; List[List[float]]:
            return [[0.0 * n]]

        calc(n=42)

    def test_nested_type_hints_2(self):
        &#34;&#34;&#34;Problem here: int != float&#34;&#34;&#34;
        @pedantic
        def calc(n: int) -&gt; List[Tuple[float, str]]:
            return [(n, str(n))]

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42)

    def test_nested_type_hints_2_corrected(self):
        @pedantic
        def calc(n: int) -&gt; List[Tuple[int, str]]:
            return [(n, str(n))]

        @pedantic
        def calc_2(n: float) -&gt; List[Tuple[float, str]]:
            return [(n, str(n))]

        calc(n=42)
        calc_2(n=42.0)

    def test_nested_type_hints_3(self):
        &#34;&#34;&#34;Problem here: inner function actually returns Tuple[int, str]&#34;&#34;&#34;
        @pedantic
        def calc(n: int) -&gt; Callable[[int, float], Tuple[float, str]]:
            @pedantic
            def f(x: int, y: float) -&gt; Tuple[float, str]:
                return n * x, str(y)
            return f

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42)(x=3, y=3.14)

    def test_nested_type_hints_3_corrected(self):
        @pedantic
        def calc(n: int) -&gt; Callable[[int, float], Tuple[int, str]]:
            @pedantic
            def f(x: int, y: float) -&gt; Tuple[int, str]:
                return n * x, str(y)

            return f

        calc(n=42)(x=3, y=3.14)

    def test_nested_type_hints_4(self):
        &#34;&#34;&#34;Problem here: return type is actually float&#34;&#34;&#34;
        @pedantic
        def calc(n: List[List[float]]) -&gt; int:
            return n[0][0]

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=[[42.0]])

    def test_nested_type_hints_corrected(self):
        @pedantic
        def calc(n: List[List[float]]) -&gt; int:
            return int(n[0][0])

        calc(n=[[42.0]])

    def test_nested_type_hints_5(self):
        &#34;&#34;&#34;Problem here: Tuple[float, str] != Tuple[float, float]&#34;&#34;&#34;

        @pedantic
        def calc(n: int) -&gt; Callable[[int, float], Tuple[float, str]]:
            @pedantic
            def f(x: int, y: float) -&gt; Tuple[float, float]:
                return n * float(x), y
            return f

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42)

    def test_nested_type_hints_5_corrected(self):
        @pedantic
        def calc(n: int) -&gt; Callable[[int, float], Tuple[float, float]]:
            @pedantic
            def f(x: int, y: float) -&gt; Tuple[float, float]:
                return n * float(x), y
            return f

        calc(n=42)

    def test_missing_type_hint_1(self):
        &#34;&#34;&#34;Problem here: type hint for n missed&#34;&#34;&#34;
        @pedantic
        def calc(n) -&gt; float:
            return 42.0 * n

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42)

    def test_missing_type_hint_1_corrected(self):
        @pedantic
        def calc(n: int) -&gt; float:
            return 42.0 * n

        calc(n=42)

    def test_missing_type_hint_2(self):
        &#34;&#34;&#34;Problem here: Return type annotation missed&#34;&#34;&#34;
        @pedantic
        def calc(n: int):
            return &#39;Hi&#39; + str(n)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42)

    def test_missing_type_hint_2_corrected(self):
        @pedantic
        def calc(n: int) -&gt; str:
            return &#39;Hi&#39; + str(n)

        calc(n=42)

    def test_missing_type_hint_3(self):
        &#34;&#34;&#34;Problem here: type hint for i missed&#34;&#34;&#34;
        @pedantic
        def calc(n: int, m: int, i) -&gt; int:
            return n + m + i

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42, m=40, i=38)

    def test_missing_type_hint_3_corrected(self):
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; int:
            return n + m + i

        calc(n=42, m=40, i=38)

    def test_all_ok_2(self):
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; str:
            return str(n + m + i)

        calc(n=42, m=40, i=38)

    def test_all_ok_3(self):
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; None:
            str(n + m + i)

        calc(n=42, m=40, i=38)

    def test_all_ok_4(self):
        @pedantic
        def calc(n: int) -&gt; List[List[int]]:
            return [[n]]

        calc(n=42)

    def test_all_ok_5(self):
        @pedantic
        def calc(n: int) -&gt; List[Tuple[float, str]]:
            return [(float(n), str(n))]

        calc(n=42)

    def test_all_ok_6(self):
        @pedantic
        def calc(n: int) -&gt; Callable[[int, float], Tuple[float, str]]:
            @pedantic
            def f(x: int, y: float) -&gt; Tuple[float, str]:
                return n * float(x), str(y)
            return f

        calc(n=42)(x=72, y=3.14)

    def test_all_ok_7(self):
        @pedantic
        def calc(n: List[List[float]]) -&gt; Any:
            return n[0][0]

        calc(n=[[42.0]])

    def test_all_ok_8(self):
        @pedantic
        def calc(n: int) -&gt; Callable[[int, float], Tuple[float, str]]:
            @pedantic
            def f(x: int, y: float) -&gt; Tuple[float, str]:
                return n * float(x), str(y)

            return f

        calc(n=42)(x=3, y=3.14)

    def test_wrong_type_hint_1(self):
        &#34;&#34;&#34;Problem here: str != int&#34;&#34;&#34;
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; str:
            return n + m + i

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42, m=40, i=38)

    def test_wrong_type_hint_1_corrected(self):
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; str:
            return str(n + m + i)

        calc(n=42, m=40, i=38)

    def test_wrong_type_hint_2(self):
        &#34;&#34;&#34;Problem here: str != int&#34;&#34;&#34;
        @pedantic
        def calc(n: int, m: int, i: str) -&gt; int:
            return n + m + i

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42, m=40, i=38)

    def test_wrong_type_hint_2_corrected(self):
        @pedantic
        def calc(n: int, m: int, i: str) -&gt; int:
            return n + m + int(i)

        calc(n=42, m=40, i=&#39;38&#39;)

    def test_wrong_type_hint_3(self):
        &#34;&#34;&#34;Problem here: None != int&#34;&#34;&#34;
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; None:
            return n + m + i

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42, m=40, i=38)

    def test_wrong_type_hint_corrected(self):
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; None:
            print(n + m + i)

        calc(n=42, m=40, i=38)

    def test_wrong_type_hint_4(self):
        &#34;&#34;&#34;Problem here: None != int&#34;&#34;&#34;
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; int:
            print(n + m + i)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42, m=40, i=38)

    def test_wrong_type_hint_4_corrected(self):
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; int:
            return n + m + i

        calc(n=42, m=40, i=38)

    def test_none_1(self):
        &#34;&#34;&#34;Problem here: None is not accepted&#34;&#34;&#34;
        @pedantic
        def calc(n: int, m: int, i: int) -&gt; int:
            return n + m + i

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42, m=40, i=None)

    def test_none_2(self):
        @pedantic
        def calc(n: int, m: int, i: Optional[int]) -&gt; int:
            return n + m + i if i is not None else n + m

        calc(n=42, m=40, i=None)

    def test_none_3(self):
        @pedantic
        def calc(n: int, m: int, i: Union[int, None]) -&gt; int:
            return n + m + i if i is not None else n + m

        calc(n=42, m=40, i=None)

    def test_none_4(self):
        &#34;&#34;&#34;Problem here: function may return None&#34;&#34;&#34;
        @pedantic
        def calc(n: int, m: int, i: Union[int, None]) -&gt; int:
            return n + m + i if i is not None else None

        calc(n=42, m=40, i=42)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(n=42, m=40, i=None)

    def test_none_5(self):
        @pedantic
        def calc(n: int, m: int, i: Union[int, None]) -&gt; Optional[int]:
            return n + m + i if i is not None else None

        calc(n=42, m=40, i=None)

    def test_inheritance_1(self):
        class MyClassA:
            pass

        class MyClassB(MyClassA):
            pass

        @pedantic
        def calc(a: MyClassA) -&gt; str:
            return str(a)

        calc(a=MyClassA())
        calc(a=MyClassB())

    def test_inheritance_2(self):
        &#34;&#34;&#34;Problem here: A is not a subtype of B&#34;&#34;&#34;
        class MyClassA:
            pass

        class MyClassB(MyClassA):
            pass

        @pedantic
        def calc(a: MyClassB) -&gt; str:
            return str(a)

        calc(a=MyClassB())
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(a=MyClassA())

    def test_instance_method_1(self):
        class MyClassA:
            @pedantic
            def calc(self, i: int) -&gt; str:
                return str(i)

        a = MyClassA()
        a.calc(i=42)

    def test_instance_method_2(self):
        &#34;&#34;&#34;Problem here: &#39;i&#39; has no type annotation&#34;&#34;&#34;
        class MyClassA:
            @pedantic
            def calc(self, i) -&gt; str:
                return str(i)

        a = MyClassA()
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            a.calc(i=42)

    def test_instance_method_2_corrected(self):
        class MyClassA:
            @pedantic
            def calc(self, i: int) -&gt; str:
                return str(i)

        a = MyClassA()
        a.calc(i=42)

    def test_instance_method_int_is_not_float(self):
        class MyClassA:
            @pedantic
            def calc(self, i: float) -&gt; str:
                return str(i)

        a = MyClassA()
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            a.calc(i=42)

    def test_instance_method_3_corrected(self):
        class MyClassA:
            @pedantic
            def calc(self, i: float) -&gt; str:
                return str(i)

        a = MyClassA()
        a.calc(i=42.0)

    def test_instance_method_no_kwargs(self):
        class MyClassA:
            @pedantic
            def calc(self, i: int) -&gt; str:
                return str(i)

        a = MyClassA()
        with self.assertRaises(expected_exception=PedanticCallWithArgsException):
            a.calc(42)

    def test_instance_method_5(self):
        &#34;&#34;&#34;Problem here: instance methods is not called with kwargs&#34;&#34;&#34;
        class MyClassA:
            @pedantic
            def calc(self, i: int) -&gt; str:
                return str(i)

        a = MyClassA()
        a.calc(i=42)

    def test_lambda_1(self):
        @pedantic
        def calc(i: float) -&gt; Callable[[float], str]:
            return lambda x: str(x * i)

        calc(i=42.0)(10.0)

    def test_lambda_3(self):
        @pedantic
        def calc(i: float) -&gt; Callable[[float], str]:
            def res(x: float) -&gt; str:
                return str(x * i)
            return res

        calc(i=42.0)(10.0)

    def test_lambda_int_is_not_float(self):
        @pedantic
        def calc(i: float) -&gt; Callable[[float], str]:
            def res(x: int) -&gt; str:
                return str(x * i)
            return res

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(i=42.0)(x=10)

    def test_lambda_4_almost_corrected(self):
        &#34;&#34;&#34;Problem here: float != str&#34;&#34;&#34;
        @pedantic
        def calc(i: float) -&gt; Callable[[float], str]:
            @pedantic
            def res(x: int) -&gt; str:
                return str(x * i)
            return res

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(i=42.0)(x=10)

    def test_lambda_4_almost_corrected_2(self):
        @pedantic
        def calc(i: float) -&gt; Callable[[int], str]:
            @pedantic
            def res(x: int) -&gt; str:
                return str(x * i)
            return res

        calc(i=42.0)(x=10)

    def test_lambda_5(self):
        &#34;&#34;&#34;Problem here: float != int&#34;&#34;&#34;
        @pedantic
        def calc(i: float) -&gt; Callable[[float], str]:
            @pedantic
            def res(x: float) -&gt; str:
                return str(x * i)
            return res

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(i=42.0)(x=10)

    def test_lambda_corrected(self):
        @pedantic
        def calc(i: float) -&gt; Callable[[float], str]:
            @pedantic
            def res(x: float) -&gt; str:
                return str(x * i)

            return res

        calc(i=42.0)(x=10.0)

    def test_tuple_without_type_args(self):
        @pedantic
        def calc(i: Tuple) -&gt; str:
            return str(i)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(i=(42.0, 43, &#39;hi&#39;))

    def test_tuple_without_args_corrected(self):
        @pedantic
        def calc(i: Tuple[Any, ...]) -&gt; str:
            return str(i)

        calc(i=(42.0, 43, &#39;hi&#39;))

    def test_callable_without_type_args(self):
        @pedantic
        def calc(i: Callable) -&gt; str:
            return str(i(&#39; you&#39;))

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(i=lambda x: (42.0, 43, &#39;hi&#39;, x))

    def test_callable_without_args_correct_with_lambdas(self):
        @pedantic
        def calc(i: Callable[[Any], Tuple[Any, ...]]) -&gt; str:
            return str(i(x=&#39; you&#39;))

        calc(i=lambda x: (42.0, 43, &#39;hi&#39;, x))

    def test_callable_without_args_corrected(self):
        @pedantic
        def calc(i: Callable[[Any], Tuple[Any, ...]]) -&gt; str:
            return str(i(x=&#39; you&#39;))

        @pedantic
        def arg(x: Any) -&gt; Tuple[Any, ...]:
            return 42.0, 43, &#39;hi&#39;, x
        calc(i=arg)

    def test_list_without_args(self):
        @pedantic
        def calc(i: List) -&gt; Any:
            return [i]

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(i=[42.0, 43, &#39;hi&#39;])

    def test_list_without_args_corrected(self):
        @pedantic
        def calc(i: List[Any]) -&gt; List[List[Any]]:
            return [i]

        calc(i=[42.0, 43, &#39;hi&#39;])

    def test_ellipsis_in_callable_1(self):
        @pedantic
        def calc(i: Callable[..., int]) -&gt; int:
            return i()

        @pedantic
        def call() -&gt; int:
            return 42

        calc(i=call)

    def test_ellipsis_in_callable_2(self):
        @pedantic
        def calc(i: Callable[..., int]) -&gt; int:
            return i(x=3.14, y=5)

        @pedantic
        def call(x: float, y: int) -&gt; int:
            return 42

        calc(i=call)

    def test_ellipsis_in_callable_3(self):
        &#34;&#34;&#34;Problem here: call to &#34;call&#34; misses one argument&#34;&#34;&#34;
        @pedantic
        def calc(i: Callable[..., int]) -&gt; int:
            return i(x=3.14)

        @pedantic
        def call(x: float, y: int) -&gt; int:
            return 42

        with self.assertRaises(expected_exception=PedanticException):
            calc(i=call)

    def test_optional_args_1(self):
        @pedantic
        def calc(a: int, b: int = 42) -&gt; int:
            return a + b

        calc(a=2)

    def test_optional_args_2(self):
        @pedantic
        def calc(a: int = 3, b: int = 42, c: float = 5.0) -&gt; float:
            return a + b + c

        calc()
        calc(a=1)
        calc(b=1)
        calc(c=1.0)
        calc(a=1, b=1)
        calc(a=1, c=1.0)
        calc(b=1, c=1.0)
        calc(a=1, b=1, c=1.0)

    def test_optional_args_3(self):
        &#34;&#34;&#34;Problem here: optional argument c: 5 is not a float&#34;&#34;&#34;
        @pedantic
        def calc(a: int = 3, b: int = 42, c: float = 5) -&gt; float:
            return a + b + c

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc()

    def test_optional_args_3_corrected(self):
        @pedantic
        def calc(a: int = 3, b: int = 42, c: float = 5.0) -&gt; float:
            return a + b + c

        calc()

    def test_optional_args_4(self):
        class MyClass:
            @pedantic
            def foo(self, a: int, b: Optional[int] = 1) -&gt; int:
                return a + b

        my_class = MyClass()
        my_class.foo(a=10)

    def test_optional_args_5(self):
        @pedantic
        def calc(d: Optional[Dict[int, int]] = None) -&gt; Optional[int]:
            if d is None:
                return None
            return sum(d.keys())

        calc(d=None)
        calc()
        calc(d={42: 3})

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(d={42: 3.14})

    def test_optional_args_6(self):
        &#34;&#34;&#34;&#34;Problem here: str != int&#34;&#34;&#34;
        @pedantic
        def calc(d: int = 42) -&gt; int:
            return int(d)

        calc(d=99999)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(d=&#39;999999&#39;)

    def test_enum_1(self):
        &#34;&#34;&#34;Problem here: Type hint for &#39;a&#39; should be MyEnum instead of MyEnum.GAMMA&#34;&#34;&#34;
        class MyEnum(Enum):
            ALPHA = &#39;startEvent&#39;
            BETA = &#39;task&#39;
            GAMMA = &#39;sequenceFlow&#39;

        class MyClass:
            @pedantic
            def operation(self, a: MyEnum.GAMMA) -&gt; None:
                print(a)

        m = MyClass()
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            m.operation(a=MyEnum.GAMMA)

    def test_enum_1_corrected(self):
        class MyEnum(Enum):
            ALPHA = &#39;startEvent&#39;
            BETA = &#39;task&#39;
            GAMMA = &#39;sequenceFlow&#39;

        @pedantic
        def operation(a: MyEnum) -&gt; None:
            print(a)

        operation(a=MyEnum.GAMMA)

    def test_sloppy_types_dict(self):
        @pedantic
        def operation(d: dict) -&gt; int:
            return len(d.keys())

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d={1: 1, 2: 2})

    def test_sloppy_types_dict_almost_corrected_no_type_args(self):
        @pedantic
        def operation(d: Dict) -&gt; int:
            return len(d.keys())

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d={1: 1, 2: 2})

    def test_sloppy_types_dict_corrected(self):
        @pedantic
        def operation(d: Dict[int, int]) -&gt; int:
            return len(d.keys())

        operation(d={1: 1, 2: 2})

    def test_sloppy_types_list(self):
        @pedantic
        def operation(d: list) -&gt; int:
            return len(d)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d=[1, 2, 3, 4])

    def test_sloppy_types_list_almost_corrected_no_type_args(self):
        @pedantic
        def operation(d: List) -&gt; int:
            return len(d)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d=[1, 2, 3, 4])

    def test_sloppy_types_list_corrected(self):
        @pedantic
        def operation(d: List[int]) -&gt; int:
            return len(d)

        operation(d=[1, 2, 3, 4])

    def test_sloppy_types_tuple(self):
        @pedantic
        def operation(d: tuple) -&gt; int:
            return len(d)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d=(1, 2, 3))

    def test_sloppy_types_tuple_almost_corrected_no_type_args(self):
        @pedantic
        def operation(d: Tuple) -&gt; int:
            return len(d)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d=(1, 2, 3))

    def test_sloppy_types_tuple_corrected(self):
        @pedantic
        def operation(d: Tuple[int, int, int]) -&gt; int:
            return len(d)

        operation(d=(1, 2, 3))

    def test_sloppy_types_set(self):
        @pedantic
        def operation(d: set) -&gt; int:
            return len(d)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d={1, 2, 3})

    def test_sloppy_types_set_almost_corrected_to_type_args(self):
        @pedantic
        def operation(d: Set) -&gt; int:
            return len(d)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d={1, 2, 3})

    def test_sloppy_types_set_corrected(self):
        @pedantic
        def operation(d: Set[int]) -&gt; int:
            return len(d)

        operation(d={1, 2, 3})

    def test_sloppy_types_frozenset(self):
        @pedantic
        def operation(d: frozenset) -&gt; int:
            return len(d)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d=frozenset({1, 2, 3}))

    def test_sloppy_types_frozenset_almost_corrected_no_type_args(self):
        @pedantic
        def operation(d: FrozenSet) -&gt; int:
            return len(d)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            operation(d=frozenset({1, 2, 3}))

    def test_sloppy_types_frozenset_corrected(self):
        @pedantic
        def operation(d: FrozenSet[int]) -&gt; int:
            return len(d)

        operation(d=frozenset({1, 2, 3}))

    def test_type_list_but_got_tuple(self):
        @pedantic
        def calc(ls: List[Any]) -&gt; int:
            return len(ls)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            calc(ls=(1, 2, 3))

    def test_type_list_corrected(self):
        @pedantic
        def calc(ls: Tuple[Any, ...]) -&gt; int:
            return len(ls)

        calc(ls=(1, 2, 3))

    def test_any(self):
        @pedantic
        def calc(ls: List[Any]) -&gt; Dict[int, Any]:
            return {i: ls[i] for i in range(0, len(ls))}

        calc(ls=[1, 2, 3])
        calc(ls=[1.11, 2.0, 3.0])
        calc(ls=[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;])
        calc(ls=[10.5, &#39;2&#39;, (3, 4, 5)])

    def test_aliases(self):
        Vector = List[float]

        @pedantic
        def scale(scalar: float, vector: Vector) -&gt; Vector:
            return [scalar * num for num in vector]

        scale(scalar=2.0, vector=[1.0, -4.2, 5.4])

    def test_new_type(self):
        UserId = NewType(&#39;UserId&#39;, int)

        @pedantic
        def get_user_name(user_id: UserId) -&gt; str:
            return str(user_id)

        some_id = UserId(524313)
        get_user_name(user_id=some_id)

        # the following would be desirable but impossible to check at runtime:
        # with self.assertRaises(expected_exception=AssertionError):
        #     get_user_name(user_id=-1)

    def test_list_of_new_type(self):
        UserId = NewType(&#39;UserId&#39;, int)

        @pedantic
        def get_user_name(user_ids: List[UserId]) -&gt; str:
            return str(user_ids)

        get_user_name(user_ids=[UserId(524313), UserId(42)])
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            get_user_name(user_ids=[UserId(524313), UserId(42), 430.0])

    def test_callable_no_args(self):
        @pedantic
        def f(g: Callable[[], str]) -&gt; str:
            return g()

        @pedantic
        def greetings() -&gt; str:
            return &#39;hello world&#39;

        f(g=greetings)

    def test_type_var(self):
        T = TypeVar(&#39;T&#39;)

        @pedantic
        def first(ls: List[T]) -&gt; T:
            return ls[0]

        first(ls=[1, 2, 3])

    def test_type_var_wrong(self):
        T = TypeVar(&#39;T&#39;)

        @pedantic
        def first(ls: List[T]) -&gt; T:
            return str(ls[0])

        with self.assertRaises(expected_exception=PedanticTypeVarMismatchException):
            first(ls=[1, 2, 3])

    def test_type_var_wrong_sequence(self):
        T = TypeVar(&#39;T&#39;)

        @pedantic
        def first(ls: Sequence[T]) -&gt; T:
            return str(ls[0])

        with self.assertRaises(expected_exception=PedanticTypeVarMismatchException):
            first(ls=[1, 2, 3])

    def test_double_pedantic(self):
        @pedantic
        @pedantic
        def f(x: int, y: float) -&gt; Tuple[float, str]:
            return float(x), str(y)

        f(x=5, y=3.14)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            f(x=5.0, y=3.14)
        with self.assertRaises(expected_exception=PedanticCallWithArgsException):
            f(5, 3.14)

    def test_args_kwargs(self):
        @pedantic
        def some_method(a: int = 0, b: float = 0.0) -&gt; float:
            return a * b

        @pedantic
        def wrapper_method(*args: Union[int, float], **kwargs: Union[int, float]) -&gt; float:
            return some_method(*args, **kwargs)

        some_method()
        with self.assertRaises(expected_exception=PedanticCallWithArgsException):
            some_method(3, 3.0)
        some_method(a=3, b=3.0)
        wrapper_method()
        with self.assertRaises(expected_exception=PedanticCallWithArgsException):
            wrapper_method(3, 3.0)
        wrapper_method(a=3, b=3.0)

    def test_args_kwargs_no_type_hint(self):
        @pedantic
        def method_no_type_hint(*args, **kwargs) -&gt; None:
            print(args)
            print(kwargs)

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            method_no_type_hint(a=3, b=3.0)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            method_no_type_hint()

    def test_args_kwargs_wrong_type_hint(self):
        &#34;&#34;&#34;See: https://www.python.org/dev/peps/pep-0484/#arbitrary-argument-lists-and-default-argument-values&#34;&#34;&#34;
        @pedantic
        def wrapper_method(*args: str, **kwargs: str) -&gt; None:
            print(args)
            print(kwargs)

        wrapper_method()
        wrapper_method(&#39;hi&#39;, &#39;you&#39;, &#39;:)&#39;)
        wrapper_method(a=&#39;hi&#39;, b=&#39;you&#39;, c=&#39;:)&#39;)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            wrapper_method(&#39;hi&#39;, &#39;you&#39;, &#39;:)&#39;, 7)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            wrapper_method(3, 3.0)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            wrapper_method(a=3, b=3.0)

    def test_additional_kwargs(self):
        @pedantic
        def some_method(a: int, b: float = 0.0, **kwargs: int) -&gt; float:
            return sum([a, b])

        some_method(a=5)
        some_method(a=5, b=0.1)
        some_method(a=5, b=0.1, c=4)
        some_method(a=5, b=0.1, c=4, d=5, e=6)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            some_method(a=5, b=0.1, c=4, d=5.0, e=6)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            some_method(a=5.0, b=0.1, c=4, d=5, e=6)
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            some_method(a=5, b=0, c=4, d=5, e=6)

    def test_args_kwargs_different_types(self):
        @pedantic
        def foo(*args: str, **kwds: int) -&gt; None:
            print(args)
            print(kwds)

        foo(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)
        foo(x=1, y=2)
        foo(&#39;&#39;, z=0)

    def test_pedantic_on_class(self):
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            @pedantic
            class MyClass:
                pass
            MyClass()

    def test_is_subtype_tuple(self):
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            @pedantic
            def foo() -&gt; Callable[[Tuple[float, str]], Tuple[int]]:
                def bar(a: Tuple[float]) -&gt; Tuple[int]:
                    return len(a[1]) + int(a[0]),
                return bar
            foo()

    def test_is_subtype_tuple_corrected(self):
        @pedantic
        def foo() -&gt; Callable[[Tuple[float, str]], Tuple[int]]:
            def bar(a: Tuple[float, str]) -&gt; Tuple[int]:
                return len(a[1]) + int(a[0]),
            return bar
        foo()

    def test_forward_ref(self):
        class Conversation:
            pass

        @pedantic
        def get_conversations() -&gt; List[&#39;Conversation&#39;]:
            return [Conversation(), Conversation()]

        get_conversations()

    def test_alternative_list_type_hint(self):
        @pedantic
        def _is_digit_in_int(digit: [int], num: int) -&gt; bool:
            num_str = str(num)
            for i in num_str:
                if int(i) == digit:
                    return True
            return False

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            _is_digit_in_int(digit=4, num=42)

    def test_callable_with_union_return(self):
        class MyClass:
            pass

        @pedantic
        def admin_required(func: Callable[..., Union[str, MyClass]]) -&gt; Callable[..., Union[str, MyClass]]:
            @wraps(func)
            def decorated_function(*args, **kwargs):
                return func(*args, **kwargs)
            return decorated_function

        @admin_required
        @pedantic
        def get_server_info() -&gt; str:
            return &#39;info&#39;

        get_server_info()

    def test_pedantic(self):
        @pedantic
        def foo(a: int, b: str) -&gt; str:
            return &#39;abc&#39;

        self.assertEqual(&#39;abc&#39;, foo(a=4, b=&#39;abc&#39;))

    def test_pedantic_always(self):
        @pedantic
        def foo(a: int, b: str) -&gt; str:
            return &#39;abc&#39;

        self.assertEqual(&#39;abc&#39;, foo(a=4, b=&#39;abc&#39;))

    def test_pedantic_arguments_fail(self):
        @pedantic
        def foo(a: int, b: str) -&gt; str:
            return &#39;abc&#39;

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            foo(a=4, b=5)

    def test_pedantic_return_type_fail(self):
        @pedantic
        def foo(a: int, b: str) -&gt; str:
            return 6

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            foo(a=4, b=&#39;abc&#39;)

    def test_return_type_none(self):
        @pedantic
        def foo() -&gt; None:
            return &#39;a&#39;
        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            foo()

    def test_marco(self):
        @pedantic_class
        class A:
            def __init__(self, val: int) -&gt; None:
                self.val = val

            def __eq__(self, other: &#39;A&#39;) -&gt; bool:  # other: A and all subclasses
                return self.val == other.val

        @pedantic_class
        class B(A):
            def __init__(self, val: int) -&gt; None:
                super().__init__(val=val)

        @pedantic_class
        class C(A):
            def __init__(self, val: int) -&gt; None:
                super().__init__(val=val)

        a = A(val=42)
        b = B(val=42)
        c = C(val=42)

        assert a == b  # works
        assert a == c  # works
        assert b == c  # error

    def test_date_datetime(self):
        @pedantic
        def foo(a: datetime, b: date) -&gt; None:
            pass

        foo(a=datetime(1995, 2, 5), b=date(1987, 8, 7))
        foo(a=datetime(1995, 2, 5), b=datetime(1987, 8, 7))

        with self.assertRaises(expected_exception=PedanticTypeCheckException):
            foo(a=date(1995, 2, 5), b=date(1987, 8, 7))

    def test_any_type(self):
        @pedantic
        def foo(a: Any) -&gt; None:
            pass

        foo(a=&#39;aa&#39;)

    def test_callable_exact_arg_count(self):
        @pedantic
        def foo(a: Callable[[int, str], int]) -&gt; None:
            pass

        def some_callable(x: int, y: str) -&gt; int:
            pass

        foo(a=some_callable)

    def test_callable_bad_type(self):
        @pedantic
        def foo(a: Callable[..., int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=5)

    def test_callable_too_few_arguments(self):
        @pedantic
        def foo(a: Callable[[int, str], int]) -&gt; None:
            pass

        def some_callable(x: int) -&gt; int:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=some_callable)

    def test_callable_mandatory_kwonlyargs(self):
        @pedantic
        def foo(a: Callable[[int, str], int]) -&gt; None:
            pass

        def some_callable(x: int, y: str, *, z: float, bar: str) -&gt; int:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=some_callable)

    def test_callable_class(self):
        &#34;&#34;&#34;
        Test that passing a class as a callable does not count the &#34;self&#34; argument &#34;a&#34;gainst the
        ones declared in the Callable specification.

        &#34;&#34;&#34;
        @pedantic
        def foo(a: Callable[[int, str], Any]) -&gt; None:
            pass

        class SomeClass:
            def __init__(self, x: int, y: str):
                pass

        foo(a=SomeClass)

    def test_callable_plain(self):
        @pedantic
        def foo(a: Callable[..., Any]) -&gt; None:
            pass

        def callback(a):
            pass

        foo(a=callback)

    def test_callable_bound_method(self):
        @pedantic
        def foo(callback: Callable[[int], Any]) -&gt; None:
            pass

        foo(callback=Child().method)

    def test_callable_defaults(self):
        &#34;&#34;&#34;
        Test that a callable having &#34;too many&#34; arguments don&#39;t raise an error if the extra
        arguments have default values.

        &#34;&#34;&#34;
        @pedantic
        def foo(callback: Callable[[int, str], Any]) -&gt; None:
            pass

        def some_callable(x: int, y: str, z: float = 1.2) -&gt; int:
            pass

        foo(callback=some_callable)

    def test_callable_builtin(self):
        @pedantic
        def foo(callback: types.BuiltinFunctionType) -&gt; None:
            pass

        foo(callback=[].append)

    def test_dict_bad_type(self):
        @pedantic
        def foo(a: Dict[str, int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=5)

    def test_dict_bad_key_type(self):
        @pedantic
        def foo(a: Dict[str, int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a={1: 2})

    def test_dict_bad_value_type(self):
        @pedantic
        def foo(a: Dict[str, int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a={&#39;x&#39;: &#39;a&#39;})

    def test_list_bad_type(self):
        @pedantic
        def foo(a: List[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=5)

    def test_list_bad_element(self):
        @pedantic
        def foo(a: List[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=[1, 2, &#39;bb&#39;])

    def test_sequence_bad_type(self):
        @pedantic
        def foo(a: Sequence[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=5)

    def test_sequence_bad_element(self):
        @pedantic
        def foo(a: Sequence[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=[1, 2, &#39;bb&#39;])

    def test_abstractset_custom_type(self):
        T = TypeVar(&#39;T&#39;)

        @pedantic_class
        class DummySet(AbstractSet[T]):
            def __contains__(self, x: object) -&gt; bool:
                return x == 1

            def __len__(self) -&gt; T:
                return 1

            def __iter__(self) -&gt; Iterator[T]:
                yield 1

        @pedantic
        def foo(a: AbstractSet[int]) -&gt; None:
            pass

        foo(a=DummySet[int]())

    def test_abstractset_bad_type(self):
        @pedantic
        def foo(a: AbstractSet[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=5)

    def test_set_bad_type(self):
        @pedantic
        def foo(a: Set[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=5)

    def test_abstractset_bad_element(self):
        @pedantic
        def foo(a: AbstractSet[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a={1, 2, &#39;bb&#39;})

    def test_set_bad_element(self):
        @pedantic
        def foo(a: Set[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a={1, 2, &#39;bb&#39;})

    def test_tuple_bad_type(self):
        @pedantic
        def foo(a: Tuple[int]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=5)

    def test_tuple_too_many_elements(self):
        @pedantic
        def foo(a: Tuple[int, str]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=(1, &#39;aa&#39;, 2))

    def test_tuple_too_few_elements(self):
        @pedantic
        def foo(a: Tuple[int, str]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=(1,))

    def test_tuple_bad_element(self):
        @pedantic
        def foo(a: Tuple[int, str]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=(1, 2))

    def test_tuple_ellipsis_bad_element(self):
        @pedantic
        def foo(a: Tuple[int, ...]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=(1, 2, &#39;blah&#39;))

    def test_namedtuple(self):
        Employee = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])

        @pedantic
        def foo(bar: Employee) -&gt; None:
            print(bar)

        foo(bar=Employee(&#39;bob&#39;, 1))

    def test_namedtuple_key_mismatch(self):
        Employee1 = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])
        Employee2 = NamedTuple(&#39;Employee&#39;, [(&#39;firstname&#39;, str), (&#39;id&#39;, int)])

        @pedantic
        def foo(bar: Employee1) -&gt; None:
            print(bar)

        with self.assertRaises(PedanticTypeCheckException):
            foo(bar=Employee2(&#39;bob&#39;, 1))

    def test_namedtuple_type_mismatch(self):
        Employee = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])

        @pedantic
        def foo(bar: Employee) -&gt; None:
            print(bar)

        with self.assertRaises(PedanticTypeCheckException):
            foo(bar=(&#39;bob&#39;, 1))

    def test_namedtuple_huge_type_mismatch(self):
        Employee = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])

        @pedantic
        def foo(bar: int) -&gt; None:
            print(bar)

        with self.assertRaises(PedanticTypeCheckException):
            foo(bar=foo(bar=Employee(&#39;bob&#39;, 1)))

    def test_namedtuple_wrong_field_type(self):
        Employee = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])

        @pedantic
        def foo(bar: Employee) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(bar=Employee(2, 1))

    def test_union(self):
        @pedantic
        def foo(a: Union[str, int]) -&gt; None:
            pass

        for value in [6, &#39;xa&#39;]:
            foo(a=value)

    def test_union_typing_type(self):
        @pedantic
        def foo(a: Union[str, Collection]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=1)

    def test_union_fail(self):
        @pedantic
        def foo(a: Union[str, int]) -&gt; None:
            pass

        for value in [5.6, b&#39;xa&#39;]:
            with self.assertRaises(PedanticTypeCheckException):
                foo(a=value)

    def test_type_var_constraints(self):
        T = TypeVar(&#39;T&#39;, int, str)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        for values in [
            {&#39;a&#39;: 6, &#39;b&#39;: 7},
            {&#39;a&#39;: &#39;aa&#39;, &#39;b&#39;: &#34;bb&#34;},
        ]:
            foo(**values)

    def test_type_var_constraints_fail_typing_type(self):
        T = TypeVar(&#39;T&#39;, int, Collection)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=&#39;aa&#39;, b=&#39;bb&#39;)

    def test_typevar_constraints_fail(self):
        T = TypeVar(&#39;T&#39;, int, str)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=2.5, b=&#39;aa&#39;)

    def test_typevar_bound(self):
        T = TypeVar(&#39;T&#39;, bound=Parent)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        foo(a=Child(), b=Child())

    def test_type_var_bound_fail(self):
        T = TypeVar(&#39;T&#39;, bound=Child)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=Parent(), b=Parent())

    def test_type_var_invariant_fail(self):
        T = TypeVar(&#39;T&#39;, int, str)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=2, b=3.6)

    def test_type_var_covariant(self):
        T = TypeVar(&#39;T&#39;, covariant=True)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        foo(a=Parent(), b=Child())

    def test_type_var_covariant_fail(self):
        T = TypeVar(&#39;T&#39;, covariant=True)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeVarMismatchException):
            foo(a=Child(), b=Parent())

    def test_type_var_contravariant(self):
        T = TypeVar(&#39;T&#39;, contravariant=True)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        foo(a=Child(), b=Parent())

    def test_type_var_contravariant_fail(self):
        T = TypeVar(&#39;T&#39;, contravariant=True)

        @pedantic
        def foo(a: T, b: T) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeVarMismatchException):
            foo(a=Parent(), b=Child())

    def test_class_bad_subclass(self):
        @pedantic
        def foo(a: Type[Child]) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=Parent)

    def test_class_any(self):
        @pedantic
        def foo(a: Type[Any]) -&gt; None:
            pass

        foo(a=str)

    def test_wrapped_function(self):
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                return func(*args, **kwargs)
            return wrapper

        @pedantic
        @decorator
        def foo(a: &#39;Child&#39;) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=Parent())

    def test_mismatching_default_type(self):
        @pedantic
        def foo(a: str = 1) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo()

    def test_implicit_default_none(self):
        &#34;&#34;&#34;
        Test that if the default value is ``None``, a ``None`` argument can be passed.

        &#34;&#34;&#34;
        @pedantic
        def foo(a: Optional[str] = None) -&gt; None:
            pass

        foo()

    def test_generator_simple(self):
        &#34;&#34;&#34;Test that argument type checking works in a generator function too.&#34;&#34;&#34;
        @pedantic
        def generate(a: int) -&gt; Generator[int, int, None]:
            yield a
            yield a + 1

        gen = generate(a=1)
        next(gen)

    def test_wrapped_generator_no_return_type_annotation(self):
        &#34;&#34;&#34;Test that return type checking works in a generator function too.&#34;&#34;&#34;
        @pedantic
        def generate(a: int) -&gt; Generator[int, int, None]:
            yield a
            yield a + 1

        gen = generate(a=1)
        next(gen)

    def test_varargs(self):
        @pedantic
        def foo(*args: int) -&gt; None:
            pass

        foo(1, 2)

    def test_varargs_fail(self):
        @pedantic
        def foo(*args: int) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(1, &#39;a&#39;)

    def test_kwargs(self):
        @pedantic
        def foo(**kwargs: int) -&gt; None:
            pass

        foo(a=1, b=2)

    def test_kwargs_fail(self):
        @pedantic
        def foo(**kwargs: int) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=1, b=&#39;a&#39;)

    def test_generic(self):
        T_Foo = TypeVar(&#39;T_Foo&#39;)

        class FooGeneric(Generic[T_Foo]):
            pass

        @pedantic
        def foo(a: FooGeneric[str]) -&gt; None:
            print(a)

        foo(a=FooGeneric[str]())

    def test_newtype(self):
        myint = NewType(&#34;myint&#34;, int)

        @pedantic
        def foo(a: myint) -&gt; int:
            return 42

        assert foo(a=1) == 42

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=&#34;a&#34;)

    def test_collection(self):
        @pedantic
        def foo(a: Collection) -&gt; None:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=True)

    def test_binary_io(self):
        @pedantic
        def foo(a: BinaryIO) -&gt; None:
            print(a)

        foo(a=BytesIO())

    def test_text_io(self):
        @pedantic
        def foo(a: TextIO) -&gt; None:
            print(a)

        foo(a=StringIO())

    def test_binary_io_fail(self):
        @pedantic
        def foo(a: TextIO) -&gt; None:
            print(a)

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=BytesIO())

    def test_text_io_fail(self):
        @pedantic
        def foo(a: BinaryIO) -&gt; None:
            print(a)

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=StringIO())

    def test_binary_io_real_file(self):
        @pedantic
        def foo(a: BinaryIO) -&gt; None:
            print(a)

        with open(file=TEST_FILE, mode=&#39;wb&#39;) as f:
            foo(a=f)

    def test_text_io_real_file(self):
        @pedantic
        def foo(a: TextIO) -&gt; None:
            print(a)

        with open(file=TEST_FILE, mode=&#39;w&#39;) as f:
            foo(a=f)

    def test_pedantic_return_type_var_fail(self):
        T = TypeVar(&#39;T&#39;, int, float)

        @pedantic
        def foo(a: T, b: T) -&gt; T:
            return &#39;a&#39;

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=4, b=2)

    def test_callable(self):
        @pedantic
        def foo_1(a: Callable[..., int]) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: Callable) -&gt; None:
            print(a)

        def some_callable() -&gt; int:
            return 4

        foo_1(a=some_callable)

        with self.assertRaises(PedanticTypeCheckException):
            foo_2(a=some_callable)

    def test_list(self):
        @pedantic
        def foo_1(a: List[int]) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: List) -&gt; None:
            print(a)

        @pedantic
        def foo_3(a: list) -&gt; None:
            print(a)

        foo_1(a=[1, 2])

        with self.assertRaises(PedanticTypeCheckException):
            foo_2(a=[1, 2])

        with self.assertRaises(PedanticTypeCheckException):
            foo_3(a=[1, 2])

    def test_dict(self):
        @pedantic
        def foo_1(a: Dict[str, int]) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: Dict) -&gt; None:
            print(a)

        @pedantic
        def foo_3(a: dict) -&gt; None:
            print(a)

        foo_1(a={&#39;x&#39;: 2})

        with self.assertRaises(PedanticTypeCheckException):
            foo_3(a={&#39;x&#39;: 2})

        with self.assertRaises(PedanticTypeCheckException):
            foo_3(a={&#39;x&#39;: 2})

    def test_sequence(self):
        @pedantic
        def foo(a: Sequence[str]) -&gt; None:
            print(a)

        for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
            foo(a=value)

    def test_sequence_no_type_args(self):
        @pedantic
        def foo(a: Sequence) -&gt; None:
            print(a)

        for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
            with self.assertRaises(PedanticTypeCheckException):
                foo(a=value)

    def test_iterable(self):
        @pedantic
        def foo(a: Iterable[str]) -&gt; None:
            print(a)

        for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
            foo(a=value)

    def test_iterable_no_type_args(self):
        @pedantic
        def foo(a: Iterable) -&gt; None:
            print(a)

        for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
            with self.assertRaises(PedanticTypeCheckException):
                foo(a=value)

    def test_container(self):
        @pedantic
        def foo(a: Container[str]) -&gt; None:
            print(a)

        for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
            foo(a=value)

    def test_container_no_type_args(self):
        @pedantic
        def foo(a: Container) -&gt; None:
            print(a)

        for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
            with self.assertRaises(PedanticTypeCheckException):
                foo(a=value)

    def test_set(self):
        @pedantic
        def foo_1(a: AbstractSet[int]) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: Set[int]) -&gt; None:
            print(a)

        for value in [set(), {6}]:
            foo_1(a=value)
            foo_2(a=value)

    def test_set_no_type_args(self):
        @pedantic
        def foo_1(a: AbstractSet) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: Set) -&gt; None:
            print(a)

        @pedantic
        def foo_3(a: set) -&gt; None:
            print(a)

        for value in [set(), {6}]:
            with self.assertRaises(PedanticTypeCheckException):
                foo_1(a=value)

            with self.assertRaises(PedanticTypeCheckException):
                foo_2(a=value)

            with self.assertRaises(PedanticTypeCheckException):
                foo_3(a=value)

    def test_tuple(self):
        @pedantic
        def foo_1(a: Tuple[int, int]) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: Tuple[int, ...]) -&gt; None:
            print(a)

        foo_1(a=(1, 2))
        foo_2(a=(1, 2))

    def test_tuple_no_type_args(self):
        @pedantic
        def foo_1(a: Tuple) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: tuple) -&gt; None:
            print(a)

        with self.assertRaises(PedanticTypeCheckException):
            foo_1(a=(1, 2))

        with self.assertRaises(PedanticTypeCheckException):
            foo_2(a=(1, 2))

    def test_empty_tuple(self):
        @pedantic
        def foo(a: Tuple[()]) -&gt; None:
            print(a)

        foo(a=())

    def test_class(self):
        @pedantic
        def foo_1(a: Type[Parent]) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: Type[TypeVar(&#39;UnboundType&#39;)]) -&gt; None:
            print(a)

        @pedantic
        def foo_3(a: Type[TypeVar(&#39;BoundType&#39;, bound=Parent)]) -&gt; None:
            print(a)

        foo_1(a=Child)
        foo_2(a=Child)
        foo_3(a=Child)

    def test_class_no_type_vars(self):
        @pedantic
        def foo_1(a: Type) -&gt; None:
            print(a)

        @pedantic
        def foo_2(a: type) -&gt; None:
            print(a)

        with self.assertRaises(PedanticTypeCheckException):
            foo_1(a=Child)

        with self.assertRaises(PedanticTypeCheckException):
            foo_2(a=Child)

    def test_class_not_a_class(self):
        @pedantic
        def foo(a: Type[Parent]) -&gt; None:
            print(a)

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=1)

    def test_complex(self):
        @pedantic
        def foo(a: complex) -&gt; None:
            print(a)

        foo(a=complex(1, 5))

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=1.0)

    def test_float(self):
        @pedantic
        def foo(a: float) -&gt; None:
            print(a)

        foo(a=1.5)

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=1)

    def test_coroutine_correct_return_type(self):
        @pedantic
        async def foo() -&gt; str:
            return &#39;foo&#39;

        coro = foo()

        with self.assertRaises(StopIteration):
            coro.send(None)

    def test_coroutine_wrong_return_type(self):
        @pedantic
        async def foo() -&gt; str:
            return 1

        coro = foo()

        with self.assertRaises(PedanticTypeCheckException):
            coro.send(None)

    def test_bytearray_bytes(self):
        @pedantic
        def foo(x: bytearray) -&gt; None:
            pass

        foo(x=bytearray([1]))

    def test_class_decorator(self):
        @pedantic_class
        class Foo:
            @staticmethod
            def staticmethod() -&gt; int:
                return &#39;foo&#39;

            @classmethod
            def classmethod(cls) -&gt; int:
                return &#39;foo&#39;

            def method(self) -&gt; int:
                return &#39;foo&#39;

        with self.assertRaises(PedanticTypeCheckException):
            Foo.staticmethod()

        with self.assertRaises(PedanticTypeCheckException):
            Foo.classmethod()

        with self.assertRaises(PedanticTypeCheckException):
            Foo().method()

    def test_generator(self):
        @pedantic
        def genfunc() -&gt; Generator[int, str, List[str]]:
            val1 = yield 2
            val2 = yield 3
            val3 = yield 4
            return [val1, val2, val3]

        gen = genfunc()

        with self.assertRaises(StopIteration):
            value = next(gen)
            while True:
                value = gen.send(str(value))
                assert isinstance(value, int)

    def test_generator_no_type_args(self):
        @pedantic
        def genfunc() -&gt; Generator:
            val1 = yield 2
            val2 = yield 3
            val3 = yield 4
            return [val1, val2, val3]

        with self.assertRaises(PedanticTypeCheckException):
            genfunc()

    def test_iterator(self):
        @pedantic
        def genfunc() -&gt; Iterator[int]:
            val1 = yield 2
            val2 = yield 3
            val3 = yield 4
            return [val1, val2, val3]

        gen = genfunc()

        with self.assertRaises(PedanticTypeCheckException):
            value = next(gen)
            while True:
                value = gen.send(str(value))
                assert isinstance(value, int)

    def test_iterator_no_type_args(self):
        @pedantic
        def genfunc() -&gt; Iterator:
            val1 = yield 2
            val2 = yield 3
            val3 = yield 4
            return [val1, val2, val3]

        with self.assertRaises(PedanticTypeCheckException):
            genfunc()

    def test_iterable_advanced(self):
        @pedantic
        def genfunc() -&gt; Iterable[int]:
            val1 = yield 2
            val2 = yield 3
            val3 = yield 4
            return [val1, val2, val3]

        gen = genfunc()

        with self.assertRaises(PedanticTypeCheckException):
            value = next(gen)
            while True:
                value = gen.send(str(value))
                assert isinstance(value, int)

    def test_iterable_advanced_no_type_args(self):
        @pedantic
        def genfunc() -&gt; Iterable:
            val1 = yield 2
            val2 = yield 3
            val3 = yield 4
            return [val1, val2, val3]

        with self.assertRaises(PedanticTypeCheckException):
            genfunc()

    def test_generator_bad_yield(self):
        @pedantic
        def genfunc_1() -&gt; Generator[int, str, None]:
            yield &#39;foo&#39;

        @pedantic
        def genfunc_2() -&gt; Iterable[int]:
            yield &#39;foo&#39;

        @pedantic
        def genfunc_3() -&gt; Iterator[int]:
            yield &#39;foo&#39;

        gen = genfunc_1()

        with self.assertRaises(PedanticTypeCheckException):
            next(gen)

        gen = genfunc_2()

        with self.assertRaises(PedanticTypeCheckException):
            next(gen)

        gen = genfunc_3()

        with self.assertRaises(PedanticTypeCheckException):
            next(gen)

    def test_generator_bad_send(self):
        @pedantic
        def genfunc() -&gt; Generator[int, str, None]:
            yield 1
            yield 2

        gen = genfunc()
        next(gen)

        with self.assertRaises(PedanticTypeCheckException):
            gen.send(2)

    def test_generator_bad_return(self):
        @pedantic
        def genfunc() -&gt; Generator[int, str, str]:
            yield 1
            return 6

        gen = genfunc()
        next(gen)

        with self.assertRaises(PedanticTypeCheckException):
            gen.send(&#39;foo&#39;)

    def test_return_generator(self):
        @pedantic
        def genfunc() -&gt; Generator[int, None, None]:
            yield 1

        @pedantic
        def foo() -&gt; Generator[int, None, None]:
            return genfunc()

        foo()

    def test_local_class(self):
        @pedantic_class
        class LocalClass:
            class Inner:
                pass

            def create_inner(self) -&gt; &#39;Inner&#39;:
                return self.Inner()

        retval = LocalClass().create_inner()
        assert isinstance(retval, LocalClass.Inner)

    def test_local_class_async(self):
        @pedantic_class
        class LocalClass:
            class Inner:
                pass

            async def create_inner(self) -&gt; &#39;Inner&#39;:
                return self.Inner()

        coro = LocalClass().create_inner()

        with self.assertRaises(StopIteration):
            coro.send(None)

    def test_callable_nonmember(self):
        class CallableClass:
            def __call__(self):
                pass

        @pedantic_class
        class LocalClass:
            some_callable = CallableClass()

    def test_inherited_class_method(self):
        @pedantic_class
        class Parent:
            @classmethod
            def foo(cls, x: str) -&gt; str:
                return cls.__name__

        @pedantic_class
        class Child(Parent):
            pass

        self.assertEqual(&#39;Parent&#39;, Child.foo(x=&#39;bar&#39;))

        with self.assertRaises(PedanticTypeCheckException):
            Child.foo(x=1)

    def test_type_var_forward_ref_bound(self):
        TBound = TypeVar(&#39;TBound&#39;, bound=&#39;Parent&#39;)

        @pedantic
        def func(x: TBound) -&gt; None:
            pass

        func(x=Parent())

        with self.assertRaises(PedanticTypeCheckException):
            func(x=&#39;foo&#39;)

    def test_noreturn(self):
        @pedantic
        def foo() -&gt; NoReturn:
            pass

        with self.assertRaises(PedanticTypeCheckException):
            foo()

    def test_literal(self):
        if sys.version_info &lt; (3, 8):
            return

        from typing import Literal

        @pedantic
        def foo(a: Literal[1, True, &#39;x&#39;, b&#39;y&#39;, 404]) -&gt; None:
            print(a)

        foo(a=404)
        foo(a=True)
        foo(a=&#39;x&#39;)

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=4)

    def test_literal_union(self):
        if sys.version_info &lt; (3, 8):
            return

        from typing import Literal

        @pedantic
        def foo(a: Union[str, Literal[1, 6, 8]]) -&gt; None:
            print(a)

        foo(a=6)

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=4)

    def test_literal_illegal_value(self):
        if sys.version_info &lt; (3, 8):
            return

        from typing import Literal

        @pedantic
        def foo(a: Literal[1, 1.1]) -&gt; None:
            print(a)

        with self.assertRaises(PedanticTypeCheckException):
            foo(a=4)

    def test_enum(self):
        with self.assertRaises(PedanticTypeCheckException):
            @pedantic_class
            class MyEnum(Enum):
                A = &#39;a&#39;

    def test_enum_aggregate(self):
        T = TypeVar(&#39;T&#39;, bound=IntEnum)

        @pedantic_class
        class EnumAggregate(Generic[T]):
            enum: ClassVar[Type[T]]

            def __init__(self, value: Union[int, str, List[T]]) -&gt; None:
                assert len(self.enum) &lt; 10

                if value == &#39;&#39;:
                    raise ValueError(f&#39;Parameter &#34;value&#34; cannot be empty!&#39;)

                if isinstance(value, list):
                    self._value = &#39;&#39;.join([str(x.value) for x in value])
                else:
                    self._value = str(value)

                self._value = &#39;&#39;.join(sorted(self._value))  # sort characters in string
                self.to_list()  # check if is valid

            def __contains__(self, item: T) -&gt; bool:
                return item in self.to_list()

            def __eq__(self, other: Union[&#39;EnumAggregate&#39;, str]) -&gt; bool:
                if isinstance(other, str):
                    return self._value == other

                return self._value == other._value

            def __str__(self) -&gt; str:
                return self._value

            def to_list(self) -&gt; List[T]:
                return [self.enum(int(character)) for character in self._value]

            @property
            def value(self) -&gt; str:
                return self._value

            @classmethod
            def all(cls) -&gt; str:
                return &#39;&#39;.join([str(x.value) for x in cls.enum])

        class Gender(IntEnum):
            MALE = 1
            FEMALE = 2
            DIVERS = 3

        @pedantic_class
        class Genders(EnumAggregate[Gender]):
            enum = Gender

        Genders(value=12)

        with self.assertRaises(PedanticTypeCheckException):
            Genders(value=Child())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.tearDown"><code class="name flex">
<span>def <span class="ident">tearDown</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for deconstructing the test fixture after testing it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tearDown(self) -&gt; None:
    if os.path.isfile(TEST_FILE):
        os.remove(TEST_FILE)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_abstractset_bad_element"><code class="name flex">
<span>def <span class="ident">test_abstractset_bad_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_abstractset_bad_element(self):
    @pedantic
    def foo(a: AbstractSet[int]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a={1, 2, &#39;bb&#39;})</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_abstractset_bad_type"><code class="name flex">
<span>def <span class="ident">test_abstractset_bad_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_abstractset_bad_type(self):
    @pedantic
    def foo(a: AbstractSet[int]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=5)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_abstractset_custom_type"><code class="name flex">
<span>def <span class="ident">test_abstractset_custom_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_abstractset_custom_type(self):
    T = TypeVar(&#39;T&#39;)

    @pedantic_class
    class DummySet(AbstractSet[T]):
        def __contains__(self, x: object) -&gt; bool:
            return x == 1

        def __len__(self) -&gt; T:
            return 1

        def __iter__(self) -&gt; Iterator[T]:
            yield 1

    @pedantic
    def foo(a: AbstractSet[int]) -&gt; None:
        pass

    foo(a=DummySet[int]())</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_additional_kwargs"><code class="name flex">
<span>def <span class="ident">test_additional_kwargs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_additional_kwargs(self):
    @pedantic
    def some_method(a: int, b: float = 0.0, **kwargs: int) -&gt; float:
        return sum([a, b])

    some_method(a=5)
    some_method(a=5, b=0.1)
    some_method(a=5, b=0.1, c=4)
    some_method(a=5, b=0.1, c=4, d=5, e=6)
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        some_method(a=5, b=0.1, c=4, d=5.0, e=6)
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        some_method(a=5.0, b=0.1, c=4, d=5, e=6)
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        some_method(a=5, b=0, c=4, d=5, e=6)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_aliases"><code class="name flex">
<span>def <span class="ident">test_aliases</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_aliases(self):
    Vector = List[float]

    @pedantic
    def scale(scalar: float, vector: Vector) -&gt; Vector:
        return [scalar * num for num in vector]

    scale(scalar=2.0, vector=[1.0, -4.2, 5.4])</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_2"><code class="name flex">
<span>def <span class="ident">test_all_ok_2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_all_ok_2(self):
    @pedantic
    def calc(n: int, m: int, i: int) -&gt; str:
        return str(n + m + i)

    calc(n=42, m=40, i=38)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_3"><code class="name flex">
<span>def <span class="ident">test_all_ok_3</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_all_ok_3(self):
    @pedantic
    def calc(n: int, m: int, i: int) -&gt; None:
        str(n + m + i)

    calc(n=42, m=40, i=38)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_4"><code class="name flex">
<span>def <span class="ident">test_all_ok_4</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_all_ok_4(self):
    @pedantic
    def calc(n: int) -&gt; List[List[int]]:
        return [[n]]

    calc(n=42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_5"><code class="name flex">
<span>def <span class="ident">test_all_ok_5</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_all_ok_5(self):
    @pedantic
    def calc(n: int) -&gt; List[Tuple[float, str]]:
        return [(float(n), str(n))]

    calc(n=42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_6"><code class="name flex">
<span>def <span class="ident">test_all_ok_6</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_all_ok_6(self):
    @pedantic
    def calc(n: int) -&gt; Callable[[int, float], Tuple[float, str]]:
        @pedantic
        def f(x: int, y: float) -&gt; Tuple[float, str]:
            return n * float(x), str(y)
        return f

    calc(n=42)(x=72, y=3.14)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_7"><code class="name flex">
<span>def <span class="ident">test_all_ok_7</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_all_ok_7(self):
    @pedantic
    def calc(n: List[List[float]]) -&gt; Any:
        return n[0][0]

    calc(n=[[42.0]])</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_8"><code class="name flex">
<span>def <span class="ident">test_all_ok_8</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_all_ok_8(self):
    @pedantic
    def calc(n: int) -&gt; Callable[[int, float], Tuple[float, str]]:
        @pedantic
        def f(x: int, y: float) -&gt; Tuple[float, str]:
            return n * float(x), str(y)

        return f

    calc(n=42)(x=3, y=3.14)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_alternative_list_type_hint"><code class="name flex">
<span>def <span class="ident">test_alternative_list_type_hint</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_alternative_list_type_hint(self):
    @pedantic
    def _is_digit_in_int(digit: [int], num: int) -&gt; bool:
        num_str = str(num)
        for i in num_str:
            if int(i) == digit:
                return True
        return False

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        _is_digit_in_int(digit=4, num=42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_any"><code class="name flex">
<span>def <span class="ident">test_any</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_any(self):
    @pedantic
    def calc(ls: List[Any]) -&gt; Dict[int, Any]:
        return {i: ls[i] for i in range(0, len(ls))}

    calc(ls=[1, 2, 3])
    calc(ls=[1.11, 2.0, 3.0])
    calc(ls=[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;])
    calc(ls=[10.5, &#39;2&#39;, (3, 4, 5)])</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_any_type"><code class="name flex">
<span>def <span class="ident">test_any_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_any_type(self):
    @pedantic
    def foo(a: Any) -&gt; None:
        pass

    foo(a=&#39;aa&#39;)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_args_kwargs"><code class="name flex">
<span>def <span class="ident">test_args_kwargs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_args_kwargs(self):
    @pedantic
    def some_method(a: int = 0, b: float = 0.0) -&gt; float:
        return a * b

    @pedantic
    def wrapper_method(*args: Union[int, float], **kwargs: Union[int, float]) -&gt; float:
        return some_method(*args, **kwargs)

    some_method()
    with self.assertRaises(expected_exception=PedanticCallWithArgsException):
        some_method(3, 3.0)
    some_method(a=3, b=3.0)
    wrapper_method()
    with self.assertRaises(expected_exception=PedanticCallWithArgsException):
        wrapper_method(3, 3.0)
    wrapper_method(a=3, b=3.0)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_args_kwargs_different_types"><code class="name flex">
<span>def <span class="ident">test_args_kwargs_different_types</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_args_kwargs_different_types(self):
    @pedantic
    def foo(*args: str, **kwds: int) -&gt; None:
        print(args)
        print(kwds)

    foo(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)
    foo(x=1, y=2)
    foo(&#39;&#39;, z=0)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_args_kwargs_no_type_hint"><code class="name flex">
<span>def <span class="ident">test_args_kwargs_no_type_hint</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_args_kwargs_no_type_hint(self):
    @pedantic
    def method_no_type_hint(*args, **kwargs) -&gt; None:
        print(args)
        print(kwargs)

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        method_no_type_hint(a=3, b=3.0)
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        method_no_type_hint()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_args_kwargs_wrong_type_hint"><code class="name flex">
<span>def <span class="ident">test_args_kwargs_wrong_type_hint</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>See: <a href="https://www.python.org/dev/peps/pep-0484/#arbitrary-argument-lists-and-default-argument-values">https://www.python.org/dev/peps/pep-0484/#arbitrary-argument-lists-and-default-argument-values</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_args_kwargs_wrong_type_hint(self):
    &#34;&#34;&#34;See: https://www.python.org/dev/peps/pep-0484/#arbitrary-argument-lists-and-default-argument-values&#34;&#34;&#34;
    @pedantic
    def wrapper_method(*args: str, **kwargs: str) -&gt; None:
        print(args)
        print(kwargs)

    wrapper_method()
    wrapper_method(&#39;hi&#39;, &#39;you&#39;, &#39;:)&#39;)
    wrapper_method(a=&#39;hi&#39;, b=&#39;you&#39;, c=&#39;:)&#39;)
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        wrapper_method(&#39;hi&#39;, &#39;you&#39;, &#39;:)&#39;, 7)
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        wrapper_method(3, 3.0)
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        wrapper_method(a=3, b=3.0)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_binary_io"><code class="name flex">
<span>def <span class="ident">test_binary_io</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_binary_io(self):
    @pedantic
    def foo(a: BinaryIO) -&gt; None:
        print(a)

    foo(a=BytesIO())</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_binary_io_fail"><code class="name flex">
<span>def <span class="ident">test_binary_io_fail</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_binary_io_fail(self):
    @pedantic
    def foo(a: TextIO) -&gt; None:
        print(a)

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=BytesIO())</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_binary_io_real_file"><code class="name flex">
<span>def <span class="ident">test_binary_io_real_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_binary_io_real_file(self):
    @pedantic
    def foo(a: BinaryIO) -&gt; None:
        print(a)

    with open(file=TEST_FILE, mode=&#39;wb&#39;) as f:
        foo(a=f)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_bytearray_bytes"><code class="name flex">
<span>def <span class="ident">test_bytearray_bytes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_bytearray_bytes(self):
    @pedantic
    def foo(x: bytearray) -&gt; None:
        pass

    foo(x=bytearray([1]))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable"><code class="name flex">
<span>def <span class="ident">test_callable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_callable(self):
    @pedantic
    def foo_1(a: Callable[..., int]) -&gt; None:
        print(a)

    @pedantic
    def foo_2(a: Callable) -&gt; None:
        print(a)

    def some_callable() -&gt; int:
        return 4

    foo_1(a=some_callable)

    with self.assertRaises(PedanticTypeCheckException):
        foo_2(a=some_callable)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_bad_type"><code class="name flex">
<span>def <span class="ident">test_callable_bad_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_callable_bad_type(self):
    @pedantic
    def foo(a: Callable[..., int]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=5)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_bound_method"><code class="name flex">
<span>def <span class="ident">test_callable_bound_method</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_callable_bound_method(self):
    @pedantic
    def foo(callback: Callable[[int], Any]) -&gt; None:
        pass

    foo(callback=Child().method)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_builtin"><code class="name flex">
<span>def <span class="ident">test_callable_builtin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_callable_builtin(self):
    @pedantic
    def foo(callback: types.BuiltinFunctionType) -&gt; None:
        pass

    foo(callback=[].append)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_class"><code class="name flex">
<span>def <span class="ident">test_callable_class</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that passing a class as a callable does not count the "self" argument "a"gainst the
ones declared in the Callable specification.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_callable_class(self):
    &#34;&#34;&#34;
    Test that passing a class as a callable does not count the &#34;self&#34; argument &#34;a&#34;gainst the
    ones declared in the Callable specification.

    &#34;&#34;&#34;
    @pedantic
    def foo(a: Callable[[int, str], Any]) -&gt; None:
        pass

    class SomeClass:
        def __init__(self, x: int, y: str):
            pass

    foo(a=SomeClass)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_defaults"><code class="name flex">
<span>def <span class="ident">test_callable_defaults</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that a callable having "too many" arguments don't raise an error if the extra
arguments have default values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_callable_defaults(self):
    &#34;&#34;&#34;
    Test that a callable having &#34;too many&#34; arguments don&#39;t raise an error if the extra
    arguments have default values.

    &#34;&#34;&#34;
    @pedantic
    def foo(callback: Callable[[int, str], Any]) -&gt; None:
        pass

    def some_callable(x: int, y: str, z: float = 1.2) -&gt; int:
        pass

    foo(callback=some_callable)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_exact_arg_count"><code class="name flex">
<span>def <span class="ident">test_callable_exact_arg_count</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_callable_exact_arg_count(self):
    @pedantic
    def foo(a: Callable[[int, str], int]) -&gt; None:
        pass

    def some_callable(x: int, y: str) -&gt; int:
        pass

    foo(a=some_callable)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_mandatory_kwonlyargs"><code class="name flex">
<span>def <span class="ident">test_callable_mandatory_kwonlyargs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_callable_mandatory_kwonlyargs(self):
    @pedantic
    def foo(a: Callable[[int, str], int]) -&gt; None:
        pass

    def some_callable(x: int, y: str, *, z: float, bar: str) -&gt; int:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=some_callable)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_no_args"><code class="name flex">
<span>def <span class="ident">test_callable_no_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_callable_no_args(self):
    @pedantic
    def f(g: Callable[[], str]) -&gt; str:
        return g()

    @pedantic
    def greetings() -&gt; str:
        return &#39;hello world&#39;

    f(g=greetings)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_nonmember"><code class="name flex">
<span>def <span class="ident">test_callable_nonmember</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_callable_nonmember(self):
    class CallableClass:
        def __call__(self):
            pass

    @pedantic_class
    class LocalClass:
        some_callable = CallableClass()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_plain"><code class="name flex">
<span>def <span class="ident">test_callable_plain</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_callable_plain(self):
    @pedantic
    def foo(a: Callable[..., Any]) -&gt; None:
        pass

    def callback(a):
        pass

    foo(a=callback)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_too_few_arguments"><code class="name flex">
<span>def <span class="ident">test_callable_too_few_arguments</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_callable_too_few_arguments(self):
    @pedantic
    def foo(a: Callable[[int, str], int]) -&gt; None:
        pass

    def some_callable(x: int) -&gt; int:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=some_callable)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_with_union_return"><code class="name flex">
<span>def <span class="ident">test_callable_with_union_return</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_callable_with_union_return(self):
    class MyClass:
        pass

    @pedantic
    def admin_required(func: Callable[..., Union[str, MyClass]]) -&gt; Callable[..., Union[str, MyClass]]:
        @wraps(func)
        def decorated_function(*args, **kwargs):
            return func(*args, **kwargs)
        return decorated_function

    @admin_required
    @pedantic
    def get_server_info() -&gt; str:
        return &#39;info&#39;

    get_server_info()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_without_args_correct_with_lambdas"><code class="name flex">
<span>def <span class="ident">test_callable_without_args_correct_with_lambdas</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_callable_without_args_correct_with_lambdas(self):
    @pedantic
    def calc(i: Callable[[Any], Tuple[Any, ...]]) -&gt; str:
        return str(i(x=&#39; you&#39;))

    calc(i=lambda x: (42.0, 43, &#39;hi&#39;, x))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_without_args_corrected"><code class="name flex">
<span>def <span class="ident">test_callable_without_args_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_callable_without_args_corrected(self):
    @pedantic
    def calc(i: Callable[[Any], Tuple[Any, ...]]) -&gt; str:
        return str(i(x=&#39; you&#39;))

    @pedantic
    def arg(x: Any) -&gt; Tuple[Any, ...]:
        return 42.0, 43, &#39;hi&#39;, x
    calc(i=arg)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_without_type_args"><code class="name flex">
<span>def <span class="ident">test_callable_without_type_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_callable_without_type_args(self):
    @pedantic
    def calc(i: Callable) -&gt; str:
        return str(i(&#39; you&#39;))

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(i=lambda x: (42.0, 43, &#39;hi&#39;, x))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class"><code class="name flex">
<span>def <span class="ident">test_class</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_class(self):
    @pedantic
    def foo_1(a: Type[Parent]) -&gt; None:
        print(a)

    @pedantic
    def foo_2(a: Type[TypeVar(&#39;UnboundType&#39;)]) -&gt; None:
        print(a)

    @pedantic
    def foo_3(a: Type[TypeVar(&#39;BoundType&#39;, bound=Parent)]) -&gt; None:
        print(a)

    foo_1(a=Child)
    foo_2(a=Child)
    foo_3(a=Child)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class_any"><code class="name flex">
<span>def <span class="ident">test_class_any</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_class_any(self):
    @pedantic
    def foo(a: Type[Any]) -&gt; None:
        pass

    foo(a=str)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class_bad_subclass"><code class="name flex">
<span>def <span class="ident">test_class_bad_subclass</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_class_bad_subclass(self):
    @pedantic
    def foo(a: Type[Child]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=Parent)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class_decorator"><code class="name flex">
<span>def <span class="ident">test_class_decorator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_class_decorator(self):
    @pedantic_class
    class Foo:
        @staticmethod
        def staticmethod() -&gt; int:
            return &#39;foo&#39;

        @classmethod
        def classmethod(cls) -&gt; int:
            return &#39;foo&#39;

        def method(self) -&gt; int:
            return &#39;foo&#39;

    with self.assertRaises(PedanticTypeCheckException):
        Foo.staticmethod()

    with self.assertRaises(PedanticTypeCheckException):
        Foo.classmethod()

    with self.assertRaises(PedanticTypeCheckException):
        Foo().method()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class_no_type_vars"><code class="name flex">
<span>def <span class="ident">test_class_no_type_vars</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_class_no_type_vars(self):
    @pedantic
    def foo_1(a: Type) -&gt; None:
        print(a)

    @pedantic
    def foo_2(a: type) -&gt; None:
        print(a)

    with self.assertRaises(PedanticTypeCheckException):
        foo_1(a=Child)

    with self.assertRaises(PedanticTypeCheckException):
        foo_2(a=Child)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class_not_a_class"><code class="name flex">
<span>def <span class="ident">test_class_not_a_class</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_class_not_a_class(self):
    @pedantic
    def foo(a: Type[Parent]) -&gt; None:
        print(a)

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=1)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_collection"><code class="name flex">
<span>def <span class="ident">test_collection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_collection(self):
    @pedantic
    def foo(a: Collection) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=True)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_complex"><code class="name flex">
<span>def <span class="ident">test_complex</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_complex(self):
    @pedantic
    def foo(a: complex) -&gt; None:
        print(a)

    foo(a=complex(1, 5))

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=1.0)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_container"><code class="name flex">
<span>def <span class="ident">test_container</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_container(self):
    @pedantic
    def foo(a: Container[str]) -&gt; None:
        print(a)

    for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
        foo(a=value)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_container_no_type_args"><code class="name flex">
<span>def <span class="ident">test_container_no_type_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_container_no_type_args(self):
    @pedantic
    def foo(a: Container) -&gt; None:
        print(a)

    for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
        with self.assertRaises(PedanticTypeCheckException):
            foo(a=value)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_coroutine_correct_return_type"><code class="name flex">
<span>def <span class="ident">test_coroutine_correct_return_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_coroutine_correct_return_type(self):
    @pedantic
    async def foo() -&gt; str:
        return &#39;foo&#39;

    coro = foo()

    with self.assertRaises(StopIteration):
        coro.send(None)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_coroutine_wrong_return_type"><code class="name flex">
<span>def <span class="ident">test_coroutine_wrong_return_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_coroutine_wrong_return_type(self):
    @pedantic
    async def foo() -&gt; str:
        return 1

    coro = foo()

    with self.assertRaises(PedanticTypeCheckException):
        coro.send(None)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_date_datetime"><code class="name flex">
<span>def <span class="ident">test_date_datetime</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_date_datetime(self):
    @pedantic
    def foo(a: datetime, b: date) -&gt; None:
        pass

    foo(a=datetime(1995, 2, 5), b=date(1987, 8, 7))
    foo(a=datetime(1995, 2, 5), b=datetime(1987, 8, 7))

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        foo(a=date(1995, 2, 5), b=date(1987, 8, 7))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_dict"><code class="name flex">
<span>def <span class="ident">test_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_dict(self):
    @pedantic
    def foo_1(a: Dict[str, int]) -&gt; None:
        print(a)

    @pedantic
    def foo_2(a: Dict) -&gt; None:
        print(a)

    @pedantic
    def foo_3(a: dict) -&gt; None:
        print(a)

    foo_1(a={&#39;x&#39;: 2})

    with self.assertRaises(PedanticTypeCheckException):
        foo_3(a={&#39;x&#39;: 2})

    with self.assertRaises(PedanticTypeCheckException):
        foo_3(a={&#39;x&#39;: 2})</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_dict_bad_key_type"><code class="name flex">
<span>def <span class="ident">test_dict_bad_key_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_dict_bad_key_type(self):
    @pedantic
    def foo(a: Dict[str, int]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a={1: 2})</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_dict_bad_type"><code class="name flex">
<span>def <span class="ident">test_dict_bad_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_dict_bad_type(self):
    @pedantic
    def foo(a: Dict[str, int]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=5)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_dict_bad_value_type"><code class="name flex">
<span>def <span class="ident">test_dict_bad_value_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_dict_bad_value_type(self):
    @pedantic
    def foo(a: Dict[str, int]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a={&#39;x&#39;: &#39;a&#39;})</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_double_pedantic"><code class="name flex">
<span>def <span class="ident">test_double_pedantic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_double_pedantic(self):
    @pedantic
    @pedantic
    def f(x: int, y: float) -&gt; Tuple[float, str]:
        return float(x), str(y)

    f(x=5, y=3.14)
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        f(x=5.0, y=3.14)
    with self.assertRaises(expected_exception=PedanticCallWithArgsException):
        f(5, 3.14)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_ellipsis_in_callable_1"><code class="name flex">
<span>def <span class="ident">test_ellipsis_in_callable_1</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_ellipsis_in_callable_1(self):
    @pedantic
    def calc(i: Callable[..., int]) -&gt; int:
        return i()

    @pedantic
    def call() -&gt; int:
        return 42

    calc(i=call)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_ellipsis_in_callable_2"><code class="name flex">
<span>def <span class="ident">test_ellipsis_in_callable_2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_ellipsis_in_callable_2(self):
    @pedantic
    def calc(i: Callable[..., int]) -&gt; int:
        return i(x=3.14, y=5)

    @pedantic
    def call(x: float, y: int) -&gt; int:
        return 42

    calc(i=call)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_ellipsis_in_callable_3"><code class="name flex">
<span>def <span class="ident">test_ellipsis_in_callable_3</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: call to "call" misses one argument</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_ellipsis_in_callable_3(self):
    &#34;&#34;&#34;Problem here: call to &#34;call&#34; misses one argument&#34;&#34;&#34;
    @pedantic
    def calc(i: Callable[..., int]) -&gt; int:
        return i(x=3.14)

    @pedantic
    def call(x: float, y: int) -&gt; int:
        return 42

    with self.assertRaises(expected_exception=PedanticException):
        calc(i=call)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_empty_tuple"><code class="name flex">
<span>def <span class="ident">test_empty_tuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_empty_tuple(self):
    @pedantic
    def foo(a: Tuple[()]) -&gt; None:
        print(a)

    foo(a=())</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_enum"><code class="name flex">
<span>def <span class="ident">test_enum</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_enum(self):
    with self.assertRaises(PedanticTypeCheckException):
        @pedantic_class
        class MyEnum(Enum):
            A = &#39;a&#39;</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_enum_1"><code class="name flex">
<span>def <span class="ident">test_enum_1</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: Type hint for 'a' should be MyEnum instead of MyEnum.GAMMA</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_enum_1(self):
    &#34;&#34;&#34;Problem here: Type hint for &#39;a&#39; should be MyEnum instead of MyEnum.GAMMA&#34;&#34;&#34;
    class MyEnum(Enum):
        ALPHA = &#39;startEvent&#39;
        BETA = &#39;task&#39;
        GAMMA = &#39;sequenceFlow&#39;

    class MyClass:
        @pedantic
        def operation(self, a: MyEnum.GAMMA) -&gt; None:
            print(a)

    m = MyClass()
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        m.operation(a=MyEnum.GAMMA)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_enum_1_corrected"><code class="name flex">
<span>def <span class="ident">test_enum_1_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_enum_1_corrected(self):
    class MyEnum(Enum):
        ALPHA = &#39;startEvent&#39;
        BETA = &#39;task&#39;
        GAMMA = &#39;sequenceFlow&#39;

    @pedantic
    def operation(a: MyEnum) -&gt; None:
        print(a)

    operation(a=MyEnum.GAMMA)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_enum_aggregate"><code class="name flex">
<span>def <span class="ident">test_enum_aggregate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_enum_aggregate(self):
    T = TypeVar(&#39;T&#39;, bound=IntEnum)

    @pedantic_class
    class EnumAggregate(Generic[T]):
        enum: ClassVar[Type[T]]

        def __init__(self, value: Union[int, str, List[T]]) -&gt; None:
            assert len(self.enum) &lt; 10

            if value == &#39;&#39;:
                raise ValueError(f&#39;Parameter &#34;value&#34; cannot be empty!&#39;)

            if isinstance(value, list):
                self._value = &#39;&#39;.join([str(x.value) for x in value])
            else:
                self._value = str(value)

            self._value = &#39;&#39;.join(sorted(self._value))  # sort characters in string
            self.to_list()  # check if is valid

        def __contains__(self, item: T) -&gt; bool:
            return item in self.to_list()

        def __eq__(self, other: Union[&#39;EnumAggregate&#39;, str]) -&gt; bool:
            if isinstance(other, str):
                return self._value == other

            return self._value == other._value

        def __str__(self) -&gt; str:
            return self._value

        def to_list(self) -&gt; List[T]:
            return [self.enum(int(character)) for character in self._value]

        @property
        def value(self) -&gt; str:
            return self._value

        @classmethod
        def all(cls) -&gt; str:
            return &#39;&#39;.join([str(x.value) for x in cls.enum])

    class Gender(IntEnum):
        MALE = 1
        FEMALE = 2
        DIVERS = 3

    @pedantic_class
    class Genders(EnumAggregate[Gender]):
        enum = Gender

    Genders(value=12)

    with self.assertRaises(PedanticTypeCheckException):
        Genders(value=Child())</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_float"><code class="name flex">
<span>def <span class="ident">test_float</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_float(self):
    @pedantic
    def foo(a: float) -&gt; None:
        print(a)

    foo(a=1.5)

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=1)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_forward_ref"><code class="name flex">
<span>def <span class="ident">test_forward_ref</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_forward_ref(self):
    class Conversation:
        pass

    @pedantic
    def get_conversations() -&gt; List[&#39;Conversation&#39;]:
        return [Conversation(), Conversation()]

    get_conversations()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator"><code class="name flex">
<span>def <span class="ident">test_generator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_generator(self):
    @pedantic
    def genfunc() -&gt; Generator[int, str, List[str]]:
        val1 = yield 2
        val2 = yield 3
        val3 = yield 4
        return [val1, val2, val3]

    gen = genfunc()

    with self.assertRaises(StopIteration):
        value = next(gen)
        while True:
            value = gen.send(str(value))
            assert isinstance(value, int)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator_bad_return"><code class="name flex">
<span>def <span class="ident">test_generator_bad_return</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_generator_bad_return(self):
    @pedantic
    def genfunc() -&gt; Generator[int, str, str]:
        yield 1
        return 6

    gen = genfunc()
    next(gen)

    with self.assertRaises(PedanticTypeCheckException):
        gen.send(&#39;foo&#39;)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator_bad_send"><code class="name flex">
<span>def <span class="ident">test_generator_bad_send</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_generator_bad_send(self):
    @pedantic
    def genfunc() -&gt; Generator[int, str, None]:
        yield 1
        yield 2

    gen = genfunc()
    next(gen)

    with self.assertRaises(PedanticTypeCheckException):
        gen.send(2)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator_bad_yield"><code class="name flex">
<span>def <span class="ident">test_generator_bad_yield</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_generator_bad_yield(self):
    @pedantic
    def genfunc_1() -&gt; Generator[int, str, None]:
        yield &#39;foo&#39;

    @pedantic
    def genfunc_2() -&gt; Iterable[int]:
        yield &#39;foo&#39;

    @pedantic
    def genfunc_3() -&gt; Iterator[int]:
        yield &#39;foo&#39;

    gen = genfunc_1()

    with self.assertRaises(PedanticTypeCheckException):
        next(gen)

    gen = genfunc_2()

    with self.assertRaises(PedanticTypeCheckException):
        next(gen)

    gen = genfunc_3()

    with self.assertRaises(PedanticTypeCheckException):
        next(gen)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator_no_type_args"><code class="name flex">
<span>def <span class="ident">test_generator_no_type_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_generator_no_type_args(self):
    @pedantic
    def genfunc() -&gt; Generator:
        val1 = yield 2
        val2 = yield 3
        val3 = yield 4
        return [val1, val2, val3]

    with self.assertRaises(PedanticTypeCheckException):
        genfunc()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator_simple"><code class="name flex">
<span>def <span class="ident">test_generator_simple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that argument type checking works in a generator function too.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_generator_simple(self):
    &#34;&#34;&#34;Test that argument type checking works in a generator function too.&#34;&#34;&#34;
    @pedantic
    def generate(a: int) -&gt; Generator[int, int, None]:
        yield a
        yield a + 1

    gen = generate(a=1)
    next(gen)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generic"><code class="name flex">
<span>def <span class="ident">test_generic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_generic(self):
    T_Foo = TypeVar(&#39;T_Foo&#39;)

    class FooGeneric(Generic[T_Foo]):
        pass

    @pedantic
    def foo(a: FooGeneric[str]) -&gt; None:
        print(a)

    foo(a=FooGeneric[str]())</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_implicit_default_none"><code class="name flex">
<span>def <span class="ident">test_implicit_default_none</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that if the default value is <code>None</code>, a <code>None</code> argument can be passed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_implicit_default_none(self):
    &#34;&#34;&#34;
    Test that if the default value is ``None``, a ``None`` argument can be passed.

    &#34;&#34;&#34;
    @pedantic
    def foo(a: Optional[str] = None) -&gt; None:
        pass

    foo()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_inheritance_1"><code class="name flex">
<span>def <span class="ident">test_inheritance_1</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_inheritance_1(self):
    class MyClassA:
        pass

    class MyClassB(MyClassA):
        pass

    @pedantic
    def calc(a: MyClassA) -&gt; str:
        return str(a)

    calc(a=MyClassA())
    calc(a=MyClassB())</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_inheritance_2"><code class="name flex">
<span>def <span class="ident">test_inheritance_2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: A is not a subtype of B</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_inheritance_2(self):
    &#34;&#34;&#34;Problem here: A is not a subtype of B&#34;&#34;&#34;
    class MyClassA:
        pass

    class MyClassB(MyClassA):
        pass

    @pedantic
    def calc(a: MyClassB) -&gt; str:
        return str(a)

    calc(a=MyClassB())
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(a=MyClassA())</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_inherited_class_method"><code class="name flex">
<span>def <span class="ident">test_inherited_class_method</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_inherited_class_method(self):
    @pedantic_class
    class Parent:
        @classmethod
        def foo(cls, x: str) -&gt; str:
            return cls.__name__

    @pedantic_class
    class Child(Parent):
        pass

    self.assertEqual(&#39;Parent&#39;, Child.foo(x=&#39;bar&#39;))

    with self.assertRaises(PedanticTypeCheckException):
        Child.foo(x=1)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_1"><code class="name flex">
<span>def <span class="ident">test_instance_method_1</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_instance_method_1(self):
    class MyClassA:
        @pedantic
        def calc(self, i: int) -&gt; str:
            return str(i)

    a = MyClassA()
    a.calc(i=42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_2"><code class="name flex">
<span>def <span class="ident">test_instance_method_2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: 'i' has no type annotation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_instance_method_2(self):
    &#34;&#34;&#34;Problem here: &#39;i&#39; has no type annotation&#34;&#34;&#34;
    class MyClassA:
        @pedantic
        def calc(self, i) -&gt; str:
            return str(i)

    a = MyClassA()
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        a.calc(i=42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_2_corrected"><code class="name flex">
<span>def <span class="ident">test_instance_method_2_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_instance_method_2_corrected(self):
    class MyClassA:
        @pedantic
        def calc(self, i: int) -&gt; str:
            return str(i)

    a = MyClassA()
    a.calc(i=42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_3_corrected"><code class="name flex">
<span>def <span class="ident">test_instance_method_3_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_instance_method_3_corrected(self):
    class MyClassA:
        @pedantic
        def calc(self, i: float) -&gt; str:
            return str(i)

    a = MyClassA()
    a.calc(i=42.0)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_5"><code class="name flex">
<span>def <span class="ident">test_instance_method_5</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: instance methods is not called with kwargs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_instance_method_5(self):
    &#34;&#34;&#34;Problem here: instance methods is not called with kwargs&#34;&#34;&#34;
    class MyClassA:
        @pedantic
        def calc(self, i: int) -&gt; str:
            return str(i)

    a = MyClassA()
    a.calc(i=42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_int_is_not_float"><code class="name flex">
<span>def <span class="ident">test_instance_method_int_is_not_float</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_instance_method_int_is_not_float(self):
    class MyClassA:
        @pedantic
        def calc(self, i: float) -&gt; str:
            return str(i)

    a = MyClassA()
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        a.calc(i=42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_no_kwargs"><code class="name flex">
<span>def <span class="ident">test_instance_method_no_kwargs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_instance_method_no_kwargs(self):
    class MyClassA:
        @pedantic
        def calc(self, i: int) -&gt; str:
            return str(i)

    a = MyClassA()
    with self.assertRaises(expected_exception=PedanticCallWithArgsException):
        a.calc(42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_is_subtype_tuple"><code class="name flex">
<span>def <span class="ident">test_is_subtype_tuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_is_subtype_tuple(self):
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        @pedantic
        def foo() -&gt; Callable[[Tuple[float, str]], Tuple[int]]:
            def bar(a: Tuple[float]) -&gt; Tuple[int]:
                return len(a[1]) + int(a[0]),
            return bar
        foo()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_is_subtype_tuple_corrected"><code class="name flex">
<span>def <span class="ident">test_is_subtype_tuple_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_is_subtype_tuple_corrected(self):
    @pedantic
    def foo() -&gt; Callable[[Tuple[float, str]], Tuple[int]]:
        def bar(a: Tuple[float, str]) -&gt; Tuple[int]:
            return len(a[1]) + int(a[0]),
        return bar
    foo()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterable"><code class="name flex">
<span>def <span class="ident">test_iterable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_iterable(self):
    @pedantic
    def foo(a: Iterable[str]) -&gt; None:
        print(a)

    for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
        foo(a=value)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterable_advanced"><code class="name flex">
<span>def <span class="ident">test_iterable_advanced</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_iterable_advanced(self):
    @pedantic
    def genfunc() -&gt; Iterable[int]:
        val1 = yield 2
        val2 = yield 3
        val3 = yield 4
        return [val1, val2, val3]

    gen = genfunc()

    with self.assertRaises(PedanticTypeCheckException):
        value = next(gen)
        while True:
            value = gen.send(str(value))
            assert isinstance(value, int)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterable_advanced_no_type_args"><code class="name flex">
<span>def <span class="ident">test_iterable_advanced_no_type_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_iterable_advanced_no_type_args(self):
    @pedantic
    def genfunc() -&gt; Iterable:
        val1 = yield 2
        val2 = yield 3
        val3 = yield 4
        return [val1, val2, val3]

    with self.assertRaises(PedanticTypeCheckException):
        genfunc()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterable_no_type_args"><code class="name flex">
<span>def <span class="ident">test_iterable_no_type_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_iterable_no_type_args(self):
    @pedantic
    def foo(a: Iterable) -&gt; None:
        print(a)

    for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
        with self.assertRaises(PedanticTypeCheckException):
            foo(a=value)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterator"><code class="name flex">
<span>def <span class="ident">test_iterator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_iterator(self):
    @pedantic
    def genfunc() -&gt; Iterator[int]:
        val1 = yield 2
        val2 = yield 3
        val3 = yield 4
        return [val1, val2, val3]

    gen = genfunc()

    with self.assertRaises(PedanticTypeCheckException):
        value = next(gen)
        while True:
            value = gen.send(str(value))
            assert isinstance(value, int)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterator_no_type_args"><code class="name flex">
<span>def <span class="ident">test_iterator_no_type_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_iterator_no_type_args(self):
    @pedantic
    def genfunc() -&gt; Iterator:
        val1 = yield 2
        val2 = yield 3
        val3 = yield 4
        return [val1, val2, val3]

    with self.assertRaises(PedanticTypeCheckException):
        genfunc()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_kwargs"><code class="name flex">
<span>def <span class="ident">test_kwargs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_kwargs(self):
    @pedantic
    def foo(**kwargs: int) -&gt; None:
        pass

    foo(a=1, b=2)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_kwargs_fail"><code class="name flex">
<span>def <span class="ident">test_kwargs_fail</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_kwargs_fail(self):
    @pedantic
    def foo(**kwargs: int) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=1, b=&#39;a&#39;)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_1"><code class="name flex">
<span>def <span class="ident">test_lambda_1</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_lambda_1(self):
    @pedantic
    def calc(i: float) -&gt; Callable[[float], str]:
        return lambda x: str(x * i)

    calc(i=42.0)(10.0)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_3"><code class="name flex">
<span>def <span class="ident">test_lambda_3</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_lambda_3(self):
    @pedantic
    def calc(i: float) -&gt; Callable[[float], str]:
        def res(x: float) -&gt; str:
            return str(x * i)
        return res

    calc(i=42.0)(10.0)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_4_almost_corrected"><code class="name flex">
<span>def <span class="ident">test_lambda_4_almost_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: float != str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_lambda_4_almost_corrected(self):
    &#34;&#34;&#34;Problem here: float != str&#34;&#34;&#34;
    @pedantic
    def calc(i: float) -&gt; Callable[[float], str]:
        @pedantic
        def res(x: int) -&gt; str:
            return str(x * i)
        return res

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(i=42.0)(x=10)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_4_almost_corrected_2"><code class="name flex">
<span>def <span class="ident">test_lambda_4_almost_corrected_2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_lambda_4_almost_corrected_2(self):
    @pedantic
    def calc(i: float) -&gt; Callable[[int], str]:
        @pedantic
        def res(x: int) -&gt; str:
            return str(x * i)
        return res

    calc(i=42.0)(x=10)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_5"><code class="name flex">
<span>def <span class="ident">test_lambda_5</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: float != int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_lambda_5(self):
    &#34;&#34;&#34;Problem here: float != int&#34;&#34;&#34;
    @pedantic
    def calc(i: float) -&gt; Callable[[float], str]:
        @pedantic
        def res(x: float) -&gt; str:
            return str(x * i)
        return res

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(i=42.0)(x=10)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_corrected"><code class="name flex">
<span>def <span class="ident">test_lambda_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_lambda_corrected(self):
    @pedantic
    def calc(i: float) -&gt; Callable[[float], str]:
        @pedantic
        def res(x: float) -&gt; str:
            return str(x * i)

        return res

    calc(i=42.0)(x=10.0)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_int_is_not_float"><code class="name flex">
<span>def <span class="ident">test_lambda_int_is_not_float</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_lambda_int_is_not_float(self):
    @pedantic
    def calc(i: float) -&gt; Callable[[float], str]:
        def res(x: int) -&gt; str:
            return str(x * i)
        return res

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(i=42.0)(x=10)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list"><code class="name flex">
<span>def <span class="ident">test_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_list(self):
    @pedantic
    def foo_1(a: List[int]) -&gt; None:
        print(a)

    @pedantic
    def foo_2(a: List) -&gt; None:
        print(a)

    @pedantic
    def foo_3(a: list) -&gt; None:
        print(a)

    foo_1(a=[1, 2])

    with self.assertRaises(PedanticTypeCheckException):
        foo_2(a=[1, 2])

    with self.assertRaises(PedanticTypeCheckException):
        foo_3(a=[1, 2])</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list_bad_element"><code class="name flex">
<span>def <span class="ident">test_list_bad_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_list_bad_element(self):
    @pedantic
    def foo(a: List[int]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=[1, 2, &#39;bb&#39;])</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list_bad_type"><code class="name flex">
<span>def <span class="ident">test_list_bad_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_list_bad_type(self):
    @pedantic
    def foo(a: List[int]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=5)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list_of_new_type"><code class="name flex">
<span>def <span class="ident">test_list_of_new_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_list_of_new_type(self):
    UserId = NewType(&#39;UserId&#39;, int)

    @pedantic
    def get_user_name(user_ids: List[UserId]) -&gt; str:
        return str(user_ids)

    get_user_name(user_ids=[UserId(524313), UserId(42)])
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        get_user_name(user_ids=[UserId(524313), UserId(42), 430.0])</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list_without_args"><code class="name flex">
<span>def <span class="ident">test_list_without_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_list_without_args(self):
    @pedantic
    def calc(i: List) -&gt; Any:
        return [i]

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(i=[42.0, 43, &#39;hi&#39;])</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list_without_args_corrected"><code class="name flex">
<span>def <span class="ident">test_list_without_args_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_list_without_args_corrected(self):
    @pedantic
    def calc(i: List[Any]) -&gt; List[List[Any]]:
        return [i]

    calc(i=[42.0, 43, &#39;hi&#39;])</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_literal"><code class="name flex">
<span>def <span class="ident">test_literal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_literal(self):
    if sys.version_info &lt; (3, 8):
        return

    from typing import Literal

    @pedantic
    def foo(a: Literal[1, True, &#39;x&#39;, b&#39;y&#39;, 404]) -&gt; None:
        print(a)

    foo(a=404)
    foo(a=True)
    foo(a=&#39;x&#39;)

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=4)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_literal_illegal_value"><code class="name flex">
<span>def <span class="ident">test_literal_illegal_value</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_literal_illegal_value(self):
    if sys.version_info &lt; (3, 8):
        return

    from typing import Literal

    @pedantic
    def foo(a: Literal[1, 1.1]) -&gt; None:
        print(a)

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=4)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_literal_union"><code class="name flex">
<span>def <span class="ident">test_literal_union</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_literal_union(self):
    if sys.version_info &lt; (3, 8):
        return

    from typing import Literal

    @pedantic
    def foo(a: Union[str, Literal[1, 6, 8]]) -&gt; None:
        print(a)

    foo(a=6)

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=4)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_local_class"><code class="name flex">
<span>def <span class="ident">test_local_class</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_local_class(self):
    @pedantic_class
    class LocalClass:
        class Inner:
            pass

        def create_inner(self) -&gt; &#39;Inner&#39;:
            return self.Inner()

    retval = LocalClass().create_inner()
    assert isinstance(retval, LocalClass.Inner)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_local_class_async"><code class="name flex">
<span>def <span class="ident">test_local_class_async</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_local_class_async(self):
    @pedantic_class
    class LocalClass:
        class Inner:
            pass

        async def create_inner(self) -&gt; &#39;Inner&#39;:
            return self.Inner()

    coro = LocalClass().create_inner()

    with self.assertRaises(StopIteration):
        coro.send(None)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_marco"><code class="name flex">
<span>def <span class="ident">test_marco</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_marco(self):
    @pedantic_class
    class A:
        def __init__(self, val: int) -&gt; None:
            self.val = val

        def __eq__(self, other: &#39;A&#39;) -&gt; bool:  # other: A and all subclasses
            return self.val == other.val

    @pedantic_class
    class B(A):
        def __init__(self, val: int) -&gt; None:
            super().__init__(val=val)

    @pedantic_class
    class C(A):
        def __init__(self, val: int) -&gt; None:
            super().__init__(val=val)

    a = A(val=42)
    b = B(val=42)
    c = C(val=42)

    assert a == b  # works
    assert a == c  # works
    assert b == c  # error</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_mismatching_default_type"><code class="name flex">
<span>def <span class="ident">test_mismatching_default_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_mismatching_default_type(self):
    @pedantic
    def foo(a: str = 1) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_1"><code class="name flex">
<span>def <span class="ident">test_missing_type_hint_1</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: type hint for n missed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_missing_type_hint_1(self):
    &#34;&#34;&#34;Problem here: type hint for n missed&#34;&#34;&#34;
    @pedantic
    def calc(n) -&gt; float:
        return 42.0 * n

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(n=42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_1_corrected"><code class="name flex">
<span>def <span class="ident">test_missing_type_hint_1_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_missing_type_hint_1_corrected(self):
    @pedantic
    def calc(n: int) -&gt; float:
        return 42.0 * n

    calc(n=42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_2"><code class="name flex">
<span>def <span class="ident">test_missing_type_hint_2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: Return type annotation missed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_missing_type_hint_2(self):
    &#34;&#34;&#34;Problem here: Return type annotation missed&#34;&#34;&#34;
    @pedantic
    def calc(n: int):
        return &#39;Hi&#39; + str(n)

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(n=42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_2_corrected"><code class="name flex">
<span>def <span class="ident">test_missing_type_hint_2_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_missing_type_hint_2_corrected(self):
    @pedantic
    def calc(n: int) -&gt; str:
        return &#39;Hi&#39; + str(n)

    calc(n=42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_3"><code class="name flex">
<span>def <span class="ident">test_missing_type_hint_3</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: type hint for i missed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_missing_type_hint_3(self):
    &#34;&#34;&#34;Problem here: type hint for i missed&#34;&#34;&#34;
    @pedantic
    def calc(n: int, m: int, i) -&gt; int:
        return n + m + i

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(n=42, m=40, i=38)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_3_corrected"><code class="name flex">
<span>def <span class="ident">test_missing_type_hint_3_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_missing_type_hint_3_corrected(self):
    @pedantic
    def calc(n: int, m: int, i: int) -&gt; int:
        return n + m + i

    calc(n=42, m=40, i=38)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_namedtuple"><code class="name flex">
<span>def <span class="ident">test_namedtuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_namedtuple(self):
    Employee = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])

    @pedantic
    def foo(bar: Employee) -&gt; None:
        print(bar)

    foo(bar=Employee(&#39;bob&#39;, 1))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_namedtuple_huge_type_mismatch"><code class="name flex">
<span>def <span class="ident">test_namedtuple_huge_type_mismatch</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_namedtuple_huge_type_mismatch(self):
    Employee = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])

    @pedantic
    def foo(bar: int) -&gt; None:
        print(bar)

    with self.assertRaises(PedanticTypeCheckException):
        foo(bar=foo(bar=Employee(&#39;bob&#39;, 1)))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_namedtuple_key_mismatch"><code class="name flex">
<span>def <span class="ident">test_namedtuple_key_mismatch</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_namedtuple_key_mismatch(self):
    Employee1 = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])
    Employee2 = NamedTuple(&#39;Employee&#39;, [(&#39;firstname&#39;, str), (&#39;id&#39;, int)])

    @pedantic
    def foo(bar: Employee1) -&gt; None:
        print(bar)

    with self.assertRaises(PedanticTypeCheckException):
        foo(bar=Employee2(&#39;bob&#39;, 1))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_namedtuple_type_mismatch"><code class="name flex">
<span>def <span class="ident">test_namedtuple_type_mismatch</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_namedtuple_type_mismatch(self):
    Employee = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])

    @pedantic
    def foo(bar: Employee) -&gt; None:
        print(bar)

    with self.assertRaises(PedanticTypeCheckException):
        foo(bar=(&#39;bob&#39;, 1))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_namedtuple_wrong_field_type"><code class="name flex">
<span>def <span class="ident">test_namedtuple_wrong_field_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_namedtuple_wrong_field_type(self):
    Employee = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])

    @pedantic
    def foo(bar: Employee) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(bar=Employee(2, 1))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_1"><code class="name flex">
<span>def <span class="ident">test_nested_type_hints_1</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_nested_type_hints_1(self):
    @pedantic
    def calc(n: int) -&gt; List[List[float]]:
        return [0.0 * n]

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(n=42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_1_corrected"><code class="name flex">
<span>def <span class="ident">test_nested_type_hints_1_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_nested_type_hints_1_corrected(self):
    @pedantic
    def calc(n: int) -&gt; List[List[float]]:
        return [[0.0 * n]]

    calc(n=42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_2"><code class="name flex">
<span>def <span class="ident">test_nested_type_hints_2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: int != float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_nested_type_hints_2(self):
    &#34;&#34;&#34;Problem here: int != float&#34;&#34;&#34;
    @pedantic
    def calc(n: int) -&gt; List[Tuple[float, str]]:
        return [(n, str(n))]

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(n=42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_2_corrected"><code class="name flex">
<span>def <span class="ident">test_nested_type_hints_2_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_nested_type_hints_2_corrected(self):
    @pedantic
    def calc(n: int) -&gt; List[Tuple[int, str]]:
        return [(n, str(n))]

    @pedantic
    def calc_2(n: float) -&gt; List[Tuple[float, str]]:
        return [(n, str(n))]

    calc(n=42)
    calc_2(n=42.0)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_3"><code class="name flex">
<span>def <span class="ident">test_nested_type_hints_3</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: inner function actually returns Tuple[int, str]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_nested_type_hints_3(self):
    &#34;&#34;&#34;Problem here: inner function actually returns Tuple[int, str]&#34;&#34;&#34;
    @pedantic
    def calc(n: int) -&gt; Callable[[int, float], Tuple[float, str]]:
        @pedantic
        def f(x: int, y: float) -&gt; Tuple[float, str]:
            return n * x, str(y)
        return f

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(n=42)(x=3, y=3.14)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_3_corrected"><code class="name flex">
<span>def <span class="ident">test_nested_type_hints_3_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_nested_type_hints_3_corrected(self):
    @pedantic
    def calc(n: int) -&gt; Callable[[int, float], Tuple[int, str]]:
        @pedantic
        def f(x: int, y: float) -&gt; Tuple[int, str]:
            return n * x, str(y)

        return f

    calc(n=42)(x=3, y=3.14)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_4"><code class="name flex">
<span>def <span class="ident">test_nested_type_hints_4</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: return type is actually float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_nested_type_hints_4(self):
    &#34;&#34;&#34;Problem here: return type is actually float&#34;&#34;&#34;
    @pedantic
    def calc(n: List[List[float]]) -&gt; int:
        return n[0][0]

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(n=[[42.0]])</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_5"><code class="name flex">
<span>def <span class="ident">test_nested_type_hints_5</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: Tuple[float, str] != Tuple[float, float]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_nested_type_hints_5(self):
    &#34;&#34;&#34;Problem here: Tuple[float, str] != Tuple[float, float]&#34;&#34;&#34;

    @pedantic
    def calc(n: int) -&gt; Callable[[int, float], Tuple[float, str]]:
        @pedantic
        def f(x: int, y: float) -&gt; Tuple[float, float]:
            return n * float(x), y
        return f

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(n=42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_5_corrected"><code class="name flex">
<span>def <span class="ident">test_nested_type_hints_5_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_nested_type_hints_5_corrected(self):
    @pedantic
    def calc(n: int) -&gt; Callable[[int, float], Tuple[float, float]]:
        @pedantic
        def f(x: int, y: float) -&gt; Tuple[float, float]:
            return n * float(x), y
        return f

    calc(n=42)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_corrected"><code class="name flex">
<span>def <span class="ident">test_nested_type_hints_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_nested_type_hints_corrected(self):
    @pedantic
    def calc(n: List[List[float]]) -&gt; int:
        return int(n[0][0])

    calc(n=[[42.0]])</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_new_type"><code class="name flex">
<span>def <span class="ident">test_new_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_new_type(self):
    UserId = NewType(&#39;UserId&#39;, int)

    @pedantic
    def get_user_name(user_id: UserId) -&gt; str:
        return str(user_id)

    some_id = UserId(524313)
    get_user_name(user_id=some_id)

    # the following would be desirable but impossible to check at runtime:
    # with self.assertRaises(expected_exception=AssertionError):
    #     get_user_name(user_id=-1)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_newtype"><code class="name flex">
<span>def <span class="ident">test_newtype</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_newtype(self):
    myint = NewType(&#34;myint&#34;, int)

    @pedantic
    def foo(a: myint) -&gt; int:
        return 42

    assert foo(a=1) == 42

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=&#34;a&#34;)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_no_kwargs"><code class="name flex">
<span>def <span class="ident">test_no_kwargs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_no_kwargs(self):
    @pedantic
    def calc(n: int, m: int, i: int) -&gt; int:
        return n + m + i

    with self.assertRaises(expected_exception=PedanticCallWithArgsException):
        calc(42, 40, 38)
    with self.assertRaises(expected_exception=PedanticCallWithArgsException):
        calc(42, m=40, i=38)
    calc(n=42, m=40, i=38)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_none_1"><code class="name flex">
<span>def <span class="ident">test_none_1</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: None is not accepted</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_none_1(self):
    &#34;&#34;&#34;Problem here: None is not accepted&#34;&#34;&#34;
    @pedantic
    def calc(n: int, m: int, i: int) -&gt; int:
        return n + m + i

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(n=42, m=40, i=None)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_none_2"><code class="name flex">
<span>def <span class="ident">test_none_2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_none_2(self):
    @pedantic
    def calc(n: int, m: int, i: Optional[int]) -&gt; int:
        return n + m + i if i is not None else n + m

    calc(n=42, m=40, i=None)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_none_3"><code class="name flex">
<span>def <span class="ident">test_none_3</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_none_3(self):
    @pedantic
    def calc(n: int, m: int, i: Union[int, None]) -&gt; int:
        return n + m + i if i is not None else n + m

    calc(n=42, m=40, i=None)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_none_4"><code class="name flex">
<span>def <span class="ident">test_none_4</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: function may return None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_none_4(self):
    &#34;&#34;&#34;Problem here: function may return None&#34;&#34;&#34;
    @pedantic
    def calc(n: int, m: int, i: Union[int, None]) -&gt; int:
        return n + m + i if i is not None else None

    calc(n=42, m=40, i=42)
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(n=42, m=40, i=None)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_none_5"><code class="name flex">
<span>def <span class="ident">test_none_5</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_none_5(self):
    @pedantic
    def calc(n: int, m: int, i: Union[int, None]) -&gt; Optional[int]:
        return n + m + i if i is not None else None

    calc(n=42, m=40, i=None)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_noreturn"><code class="name flex">
<span>def <span class="ident">test_noreturn</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_noreturn(self):
    @pedantic
    def foo() -&gt; NoReturn:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_1"><code class="name flex">
<span>def <span class="ident">test_optional_args_1</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_optional_args_1(self):
    @pedantic
    def calc(a: int, b: int = 42) -&gt; int:
        return a + b

    calc(a=2)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_2"><code class="name flex">
<span>def <span class="ident">test_optional_args_2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_optional_args_2(self):
    @pedantic
    def calc(a: int = 3, b: int = 42, c: float = 5.0) -&gt; float:
        return a + b + c

    calc()
    calc(a=1)
    calc(b=1)
    calc(c=1.0)
    calc(a=1, b=1)
    calc(a=1, c=1.0)
    calc(b=1, c=1.0)
    calc(a=1, b=1, c=1.0)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_3"><code class="name flex">
<span>def <span class="ident">test_optional_args_3</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: optional argument c: 5 is not a float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_optional_args_3(self):
    &#34;&#34;&#34;Problem here: optional argument c: 5 is not a float&#34;&#34;&#34;
    @pedantic
    def calc(a: int = 3, b: int = 42, c: float = 5) -&gt; float:
        return a + b + c

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_3_corrected"><code class="name flex">
<span>def <span class="ident">test_optional_args_3_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_optional_args_3_corrected(self):
    @pedantic
    def calc(a: int = 3, b: int = 42, c: float = 5.0) -&gt; float:
        return a + b + c

    calc()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_4"><code class="name flex">
<span>def <span class="ident">test_optional_args_4</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_optional_args_4(self):
    class MyClass:
        @pedantic
        def foo(self, a: int, b: Optional[int] = 1) -&gt; int:
            return a + b

    my_class = MyClass()
    my_class.foo(a=10)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_5"><code class="name flex">
<span>def <span class="ident">test_optional_args_5</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_optional_args_5(self):
    @pedantic
    def calc(d: Optional[Dict[int, int]] = None) -&gt; Optional[int]:
        if d is None:
            return None
        return sum(d.keys())

    calc(d=None)
    calc()
    calc(d={42: 3})

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(d={42: 3.14})</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_6"><code class="name flex">
<span>def <span class="ident">test_optional_args_6</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>"Problem here: str != int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_optional_args_6(self):
    &#34;&#34;&#34;&#34;Problem here: str != int&#34;&#34;&#34;
    @pedantic
    def calc(d: int = 42) -&gt; int:
        return int(d)

    calc(d=99999)
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(d=&#39;999999&#39;)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic"><code class="name flex">
<span>def <span class="ident">test_pedantic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_pedantic(self):
    @pedantic
    def foo(a: int, b: str) -&gt; str:
        return &#39;abc&#39;

    self.assertEqual(&#39;abc&#39;, foo(a=4, b=&#39;abc&#39;))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic_always"><code class="name flex">
<span>def <span class="ident">test_pedantic_always</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_pedantic_always(self):
    @pedantic
    def foo(a: int, b: str) -&gt; str:
        return &#39;abc&#39;

    self.assertEqual(&#39;abc&#39;, foo(a=4, b=&#39;abc&#39;))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic_arguments_fail"><code class="name flex">
<span>def <span class="ident">test_pedantic_arguments_fail</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_pedantic_arguments_fail(self):
    @pedantic
    def foo(a: int, b: str) -&gt; str:
        return &#39;abc&#39;

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        foo(a=4, b=5)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic_on_class"><code class="name flex">
<span>def <span class="ident">test_pedantic_on_class</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_pedantic_on_class(self):
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        @pedantic
        class MyClass:
            pass
        MyClass()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic_return_type_fail"><code class="name flex">
<span>def <span class="ident">test_pedantic_return_type_fail</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_pedantic_return_type_fail(self):
    @pedantic
    def foo(a: int, b: str) -&gt; str:
        return 6

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        foo(a=4, b=&#39;abc&#39;)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic_return_type_var_fail"><code class="name flex">
<span>def <span class="ident">test_pedantic_return_type_var_fail</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_pedantic_return_type_var_fail(self):
    T = TypeVar(&#39;T&#39;, int, float)

    @pedantic
    def foo(a: T, b: T) -&gt; T:
        return &#39;a&#39;

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=4, b=2)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_return_generator"><code class="name flex">
<span>def <span class="ident">test_return_generator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_return_generator(self):
    @pedantic
    def genfunc() -&gt; Generator[int, None, None]:
        yield 1

    @pedantic
    def foo() -&gt; Generator[int, None, None]:
        return genfunc()

    foo()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_return_type_none"><code class="name flex">
<span>def <span class="ident">test_return_type_none</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_return_type_none(self):
    @pedantic
    def foo() -&gt; None:
        return &#39;a&#39;
    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        foo()</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sequence"><code class="name flex">
<span>def <span class="ident">test_sequence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sequence(self):
    @pedantic
    def foo(a: Sequence[str]) -&gt; None:
        print(a)

    for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
        foo(a=value)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sequence_bad_element"><code class="name flex">
<span>def <span class="ident">test_sequence_bad_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sequence_bad_element(self):
    @pedantic
    def foo(a: Sequence[int]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=[1, 2, &#39;bb&#39;])</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sequence_bad_type"><code class="name flex">
<span>def <span class="ident">test_sequence_bad_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sequence_bad_type(self):
    @pedantic
    def foo(a: Sequence[int]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=5)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sequence_no_type_args"><code class="name flex">
<span>def <span class="ident">test_sequence_no_type_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sequence_no_type_args(self):
    @pedantic
    def foo(a: Sequence) -&gt; None:
        print(a)

    for value in [(&#39;a&#39;, &#39;b&#39;), [&#39;a&#39;, &#39;b&#39;], &#39;abc&#39;]:
        with self.assertRaises(PedanticTypeCheckException):
            foo(a=value)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_set"><code class="name flex">
<span>def <span class="ident">test_set</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_set(self):
    @pedantic
    def foo_1(a: AbstractSet[int]) -&gt; None:
        print(a)

    @pedantic
    def foo_2(a: Set[int]) -&gt; None:
        print(a)

    for value in [set(), {6}]:
        foo_1(a=value)
        foo_2(a=value)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_set_bad_element"><code class="name flex">
<span>def <span class="ident">test_set_bad_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_set_bad_element(self):
    @pedantic
    def foo(a: Set[int]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a={1, 2, &#39;bb&#39;})</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_set_bad_type"><code class="name flex">
<span>def <span class="ident">test_set_bad_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_set_bad_type(self):
    @pedantic
    def foo(a: Set[int]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=5)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_set_no_type_args"><code class="name flex">
<span>def <span class="ident">test_set_no_type_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_set_no_type_args(self):
    @pedantic
    def foo_1(a: AbstractSet) -&gt; None:
        print(a)

    @pedantic
    def foo_2(a: Set) -&gt; None:
        print(a)

    @pedantic
    def foo_3(a: set) -&gt; None:
        print(a)

    for value in [set(), {6}]:
        with self.assertRaises(PedanticTypeCheckException):
            foo_1(a=value)

        with self.assertRaises(PedanticTypeCheckException):
            foo_2(a=value)

        with self.assertRaises(PedanticTypeCheckException):
            foo_3(a=value)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_dict"><code class="name flex">
<span>def <span class="ident">test_sloppy_types_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sloppy_types_dict(self):
    @pedantic
    def operation(d: dict) -&gt; int:
        return len(d.keys())

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        operation(d={1: 1, 2: 2})</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_dict_almost_corrected_no_type_args"><code class="name flex">
<span>def <span class="ident">test_sloppy_types_dict_almost_corrected_no_type_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sloppy_types_dict_almost_corrected_no_type_args(self):
    @pedantic
    def operation(d: Dict) -&gt; int:
        return len(d.keys())

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        operation(d={1: 1, 2: 2})</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_dict_corrected"><code class="name flex">
<span>def <span class="ident">test_sloppy_types_dict_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sloppy_types_dict_corrected(self):
    @pedantic
    def operation(d: Dict[int, int]) -&gt; int:
        return len(d.keys())

    operation(d={1: 1, 2: 2})</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_frozenset"><code class="name flex">
<span>def <span class="ident">test_sloppy_types_frozenset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sloppy_types_frozenset(self):
    @pedantic
    def operation(d: frozenset) -&gt; int:
        return len(d)

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        operation(d=frozenset({1, 2, 3}))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_frozenset_almost_corrected_no_type_args"><code class="name flex">
<span>def <span class="ident">test_sloppy_types_frozenset_almost_corrected_no_type_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sloppy_types_frozenset_almost_corrected_no_type_args(self):
    @pedantic
    def operation(d: FrozenSet) -&gt; int:
        return len(d)

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        operation(d=frozenset({1, 2, 3}))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_frozenset_corrected"><code class="name flex">
<span>def <span class="ident">test_sloppy_types_frozenset_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sloppy_types_frozenset_corrected(self):
    @pedantic
    def operation(d: FrozenSet[int]) -&gt; int:
        return len(d)

    operation(d=frozenset({1, 2, 3}))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_list"><code class="name flex">
<span>def <span class="ident">test_sloppy_types_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sloppy_types_list(self):
    @pedantic
    def operation(d: list) -&gt; int:
        return len(d)

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        operation(d=[1, 2, 3, 4])</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_list_almost_corrected_no_type_args"><code class="name flex">
<span>def <span class="ident">test_sloppy_types_list_almost_corrected_no_type_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sloppy_types_list_almost_corrected_no_type_args(self):
    @pedantic
    def operation(d: List) -&gt; int:
        return len(d)

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        operation(d=[1, 2, 3, 4])</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_list_corrected"><code class="name flex">
<span>def <span class="ident">test_sloppy_types_list_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sloppy_types_list_corrected(self):
    @pedantic
    def operation(d: List[int]) -&gt; int:
        return len(d)

    operation(d=[1, 2, 3, 4])</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_set"><code class="name flex">
<span>def <span class="ident">test_sloppy_types_set</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sloppy_types_set(self):
    @pedantic
    def operation(d: set) -&gt; int:
        return len(d)

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        operation(d={1, 2, 3})</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_set_almost_corrected_to_type_args"><code class="name flex">
<span>def <span class="ident">test_sloppy_types_set_almost_corrected_to_type_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sloppy_types_set_almost_corrected_to_type_args(self):
    @pedantic
    def operation(d: Set) -&gt; int:
        return len(d)

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        operation(d={1, 2, 3})</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_set_corrected"><code class="name flex">
<span>def <span class="ident">test_sloppy_types_set_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sloppy_types_set_corrected(self):
    @pedantic
    def operation(d: Set[int]) -&gt; int:
        return len(d)

    operation(d={1, 2, 3})</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_tuple"><code class="name flex">
<span>def <span class="ident">test_sloppy_types_tuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sloppy_types_tuple(self):
    @pedantic
    def operation(d: tuple) -&gt; int:
        return len(d)

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        operation(d=(1, 2, 3))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_tuple_almost_corrected_no_type_args"><code class="name flex">
<span>def <span class="ident">test_sloppy_types_tuple_almost_corrected_no_type_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sloppy_types_tuple_almost_corrected_no_type_args(self):
    @pedantic
    def operation(d: Tuple) -&gt; int:
        return len(d)

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        operation(d=(1, 2, 3))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_tuple_corrected"><code class="name flex">
<span>def <span class="ident">test_sloppy_types_tuple_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_sloppy_types_tuple_corrected(self):
    @pedantic
    def operation(d: Tuple[int, int, int]) -&gt; int:
        return len(d)

    operation(d=(1, 2, 3))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_text_io"><code class="name flex">
<span>def <span class="ident">test_text_io</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_text_io(self):
    @pedantic
    def foo(a: TextIO) -&gt; None:
        print(a)

    foo(a=StringIO())</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_text_io_fail"><code class="name flex">
<span>def <span class="ident">test_text_io_fail</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_text_io_fail(self):
    @pedantic
    def foo(a: BinaryIO) -&gt; None:
        print(a)

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=StringIO())</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_text_io_real_file"><code class="name flex">
<span>def <span class="ident">test_text_io_real_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_text_io_real_file(self):
    @pedantic
    def foo(a: TextIO) -&gt; None:
        print(a)

    with open(file=TEST_FILE, mode=&#39;w&#39;) as f:
        foo(a=f)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple"><code class="name flex">
<span>def <span class="ident">test_tuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_tuple(self):
    @pedantic
    def foo_1(a: Tuple[int, int]) -&gt; None:
        print(a)

    @pedantic
    def foo_2(a: Tuple[int, ...]) -&gt; None:
        print(a)

    foo_1(a=(1, 2))
    foo_2(a=(1, 2))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_bad_element"><code class="name flex">
<span>def <span class="ident">test_tuple_bad_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_tuple_bad_element(self):
    @pedantic
    def foo(a: Tuple[int, str]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=(1, 2))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_bad_type"><code class="name flex">
<span>def <span class="ident">test_tuple_bad_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_tuple_bad_type(self):
    @pedantic
    def foo(a: Tuple[int]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=5)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_ellipsis_bad_element"><code class="name flex">
<span>def <span class="ident">test_tuple_ellipsis_bad_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_tuple_ellipsis_bad_element(self):
    @pedantic
    def foo(a: Tuple[int, ...]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=(1, 2, &#39;blah&#39;))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_no_type_args"><code class="name flex">
<span>def <span class="ident">test_tuple_no_type_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_tuple_no_type_args(self):
    @pedantic
    def foo_1(a: Tuple) -&gt; None:
        print(a)

    @pedantic
    def foo_2(a: tuple) -&gt; None:
        print(a)

    with self.assertRaises(PedanticTypeCheckException):
        foo_1(a=(1, 2))

    with self.assertRaises(PedanticTypeCheckException):
        foo_2(a=(1, 2))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_too_few_elements"><code class="name flex">
<span>def <span class="ident">test_tuple_too_few_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_tuple_too_few_elements(self):
    @pedantic
    def foo(a: Tuple[int, str]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=(1,))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_too_many_elements"><code class="name flex">
<span>def <span class="ident">test_tuple_too_many_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_tuple_too_many_elements(self):
    @pedantic
    def foo(a: Tuple[int, str]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=(1, &#39;aa&#39;, 2))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_without_args_corrected"><code class="name flex">
<span>def <span class="ident">test_tuple_without_args_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_tuple_without_args_corrected(self):
    @pedantic
    def calc(i: Tuple[Any, ...]) -&gt; str:
        return str(i)

    calc(i=(42.0, 43, &#39;hi&#39;))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_without_type_args"><code class="name flex">
<span>def <span class="ident">test_tuple_without_type_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_tuple_without_type_args(self):
    @pedantic
    def calc(i: Tuple) -&gt; str:
        return str(i)

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(i=(42.0, 43, &#39;hi&#39;))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_list_but_got_tuple"><code class="name flex">
<span>def <span class="ident">test_type_list_but_got_tuple</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_type_list_but_got_tuple(self):
    @pedantic
    def calc(ls: List[Any]) -&gt; int:
        return len(ls)

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(ls=(1, 2, 3))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_list_corrected"><code class="name flex">
<span>def <span class="ident">test_type_list_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_type_list_corrected(self):
    @pedantic
    def calc(ls: Tuple[Any, ...]) -&gt; int:
        return len(ls)

    calc(ls=(1, 2, 3))</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var"><code class="name flex">
<span>def <span class="ident">test_type_var</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_type_var(self):
    T = TypeVar(&#39;T&#39;)

    @pedantic
    def first(ls: List[T]) -&gt; T:
        return ls[0]

    first(ls=[1, 2, 3])</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_bound_fail"><code class="name flex">
<span>def <span class="ident">test_type_var_bound_fail</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_type_var_bound_fail(self):
    T = TypeVar(&#39;T&#39;, bound=Child)

    @pedantic
    def foo(a: T, b: T) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=Parent(), b=Parent())</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_constraints"><code class="name flex">
<span>def <span class="ident">test_type_var_constraints</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_type_var_constraints(self):
    T = TypeVar(&#39;T&#39;, int, str)

    @pedantic
    def foo(a: T, b: T) -&gt; None:
        pass

    for values in [
        {&#39;a&#39;: 6, &#39;b&#39;: 7},
        {&#39;a&#39;: &#39;aa&#39;, &#39;b&#39;: &#34;bb&#34;},
    ]:
        foo(**values)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_constraints_fail_typing_type"><code class="name flex">
<span>def <span class="ident">test_type_var_constraints_fail_typing_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_type_var_constraints_fail_typing_type(self):
    T = TypeVar(&#39;T&#39;, int, Collection)

    @pedantic
    def foo(a: T, b: T) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=&#39;aa&#39;, b=&#39;bb&#39;)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_contravariant"><code class="name flex">
<span>def <span class="ident">test_type_var_contravariant</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_type_var_contravariant(self):
    T = TypeVar(&#39;T&#39;, contravariant=True)

    @pedantic
    def foo(a: T, b: T) -&gt; None:
        pass

    foo(a=Child(), b=Parent())</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_contravariant_fail"><code class="name flex">
<span>def <span class="ident">test_type_var_contravariant_fail</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_type_var_contravariant_fail(self):
    T = TypeVar(&#39;T&#39;, contravariant=True)

    @pedantic
    def foo(a: T, b: T) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeVarMismatchException):
        foo(a=Parent(), b=Child())</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_covariant"><code class="name flex">
<span>def <span class="ident">test_type_var_covariant</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_type_var_covariant(self):
    T = TypeVar(&#39;T&#39;, covariant=True)

    @pedantic
    def foo(a: T, b: T) -&gt; None:
        pass

    foo(a=Parent(), b=Child())</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_covariant_fail"><code class="name flex">
<span>def <span class="ident">test_type_var_covariant_fail</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_type_var_covariant_fail(self):
    T = TypeVar(&#39;T&#39;, covariant=True)

    @pedantic
    def foo(a: T, b: T) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeVarMismatchException):
        foo(a=Child(), b=Parent())</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_forward_ref_bound"><code class="name flex">
<span>def <span class="ident">test_type_var_forward_ref_bound</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_type_var_forward_ref_bound(self):
    TBound = TypeVar(&#39;TBound&#39;, bound=&#39;Parent&#39;)

    @pedantic
    def func(x: TBound) -&gt; None:
        pass

    func(x=Parent())

    with self.assertRaises(PedanticTypeCheckException):
        func(x=&#39;foo&#39;)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_invariant_fail"><code class="name flex">
<span>def <span class="ident">test_type_var_invariant_fail</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_type_var_invariant_fail(self):
    T = TypeVar(&#39;T&#39;, int, str)

    @pedantic
    def foo(a: T, b: T) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=2, b=3.6)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_wrong"><code class="name flex">
<span>def <span class="ident">test_type_var_wrong</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_type_var_wrong(self):
    T = TypeVar(&#39;T&#39;)

    @pedantic
    def first(ls: List[T]) -&gt; T:
        return str(ls[0])

    with self.assertRaises(expected_exception=PedanticTypeVarMismatchException):
        first(ls=[1, 2, 3])</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_wrong_sequence"><code class="name flex">
<span>def <span class="ident">test_type_var_wrong_sequence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_type_var_wrong_sequence(self):
    T = TypeVar(&#39;T&#39;)

    @pedantic
    def first(ls: Sequence[T]) -&gt; T:
        return str(ls[0])

    with self.assertRaises(expected_exception=PedanticTypeVarMismatchException):
        first(ls=[1, 2, 3])</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_typevar_bound"><code class="name flex">
<span>def <span class="ident">test_typevar_bound</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_typevar_bound(self):
    T = TypeVar(&#39;T&#39;, bound=Parent)

    @pedantic
    def foo(a: T, b: T) -&gt; None:
        pass

    foo(a=Child(), b=Child())</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_typevar_constraints_fail"><code class="name flex">
<span>def <span class="ident">test_typevar_constraints_fail</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_typevar_constraints_fail(self):
    T = TypeVar(&#39;T&#39;, int, str)

    @pedantic
    def foo(a: T, b: T) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=2.5, b=&#39;aa&#39;)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_union"><code class="name flex">
<span>def <span class="ident">test_union</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_union(self):
    @pedantic
    def foo(a: Union[str, int]) -&gt; None:
        pass

    for value in [6, &#39;xa&#39;]:
        foo(a=value)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_union_fail"><code class="name flex">
<span>def <span class="ident">test_union_fail</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_union_fail(self):
    @pedantic
    def foo(a: Union[str, int]) -&gt; None:
        pass

    for value in [5.6, b&#39;xa&#39;]:
        with self.assertRaises(PedanticTypeCheckException):
            foo(a=value)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_union_typing_type"><code class="name flex">
<span>def <span class="ident">test_union_typing_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_union_typing_type(self):
    @pedantic
    def foo(a: Union[str, Collection]) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=1)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_varargs"><code class="name flex">
<span>def <span class="ident">test_varargs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_varargs(self):
    @pedantic
    def foo(*args: int) -&gt; None:
        pass

    foo(1, 2)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_varargs_fail"><code class="name flex">
<span>def <span class="ident">test_varargs_fail</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_varargs_fail(self):
    @pedantic
    def foo(*args: int) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(1, &#39;a&#39;)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrapped_function"><code class="name flex">
<span>def <span class="ident">test_wrapped_function</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_wrapped_function(self):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        return wrapper

    @pedantic
    @decorator
    def foo(a: &#39;Child&#39;) -&gt; None:
        pass

    with self.assertRaises(PedanticTypeCheckException):
        foo(a=Parent())</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrapped_generator_no_return_type_annotation"><code class="name flex">
<span>def <span class="ident">test_wrapped_generator_no_return_type_annotation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test that return type checking works in a generator function too.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_wrapped_generator_no_return_type_annotation(self):
    &#34;&#34;&#34;Test that return type checking works in a generator function too.&#34;&#34;&#34;
    @pedantic
    def generate(a: int) -&gt; Generator[int, int, None]:
        yield a
        yield a + 1

    gen = generate(a=1)
    next(gen)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_1"><code class="name flex">
<span>def <span class="ident">test_wrong_type_hint_1</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: str != int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_wrong_type_hint_1(self):
    &#34;&#34;&#34;Problem here: str != int&#34;&#34;&#34;
    @pedantic
    def calc(n: int, m: int, i: int) -&gt; str:
        return n + m + i

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(n=42, m=40, i=38)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_1_corrected"><code class="name flex">
<span>def <span class="ident">test_wrong_type_hint_1_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_wrong_type_hint_1_corrected(self):
    @pedantic
    def calc(n: int, m: int, i: int) -&gt; str:
        return str(n + m + i)

    calc(n=42, m=40, i=38)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_2"><code class="name flex">
<span>def <span class="ident">test_wrong_type_hint_2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: str != int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_wrong_type_hint_2(self):
    &#34;&#34;&#34;Problem here: str != int&#34;&#34;&#34;
    @pedantic
    def calc(n: int, m: int, i: str) -&gt; int:
        return n + m + i

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(n=42, m=40, i=38)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_2_corrected"><code class="name flex">
<span>def <span class="ident">test_wrong_type_hint_2_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_wrong_type_hint_2_corrected(self):
    @pedantic
    def calc(n: int, m: int, i: str) -&gt; int:
        return n + m + int(i)

    calc(n=42, m=40, i=&#39;38&#39;)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_3"><code class="name flex">
<span>def <span class="ident">test_wrong_type_hint_3</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: None != int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_wrong_type_hint_3(self):
    &#34;&#34;&#34;Problem here: None != int&#34;&#34;&#34;
    @pedantic
    def calc(n: int, m: int, i: int) -&gt; None:
        return n + m + i

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(n=42, m=40, i=38)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_4"><code class="name flex">
<span>def <span class="ident">test_wrong_type_hint_4</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Problem here: None != int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_wrong_type_hint_4(self):
    &#34;&#34;&#34;Problem here: None != int&#34;&#34;&#34;
    @pedantic
    def calc(n: int, m: int, i: int) -&gt; int:
        print(n + m + i)

    with self.assertRaises(expected_exception=PedanticTypeCheckException):
        calc(n=42, m=40, i=38)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_4_corrected"><code class="name flex">
<span>def <span class="ident">test_wrong_type_hint_4_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_wrong_type_hint_4_corrected(self):
    @pedantic
    def calc(n: int, m: int, i: int) -&gt; int:
        return n + m + i

    calc(n=42, m=40, i=38)</code></pre>
</details>
</dd>
<dt id="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_corrected"><code class="name flex">
<span>def <span class="ident">test_wrong_type_hint_corrected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_wrong_type_hint_corrected(self):
    @pedantic
    def calc(n: int, m: int, i: int) -&gt; None:
        print(n + m + i)

    calc(n=42, m=40, i=38)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pedantic.tests" href="index.html">pedantic.tests</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pedantic.tests.tests_pedantic.Child" href="#pedantic.tests.tests_pedantic.Child">Child</a></code></h4>
<ul class="">
<li><code><a title="pedantic.tests.tests_pedantic.Child.method" href="#pedantic.tests.tests_pedantic.Child.method">method</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pedantic.tests.tests_pedantic.Parent" href="#pedantic.tests.tests_pedantic.Parent">Parent</a></code></h4>
</li>
<li>
<h4><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck">TestDecoratorRequireKwargsAndTypeCheck</a></code></h4>
<ul class="">
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.tearDown" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.tearDown">tearDown</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_abstractset_bad_element" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_abstractset_bad_element">test_abstractset_bad_element</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_abstractset_bad_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_abstractset_bad_type">test_abstractset_bad_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_abstractset_custom_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_abstractset_custom_type">test_abstractset_custom_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_additional_kwargs" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_additional_kwargs">test_additional_kwargs</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_aliases" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_aliases">test_aliases</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_2" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_2">test_all_ok_2</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_3" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_3">test_all_ok_3</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_4" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_4">test_all_ok_4</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_5" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_5">test_all_ok_5</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_6" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_6">test_all_ok_6</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_7" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_7">test_all_ok_7</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_8" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_all_ok_8">test_all_ok_8</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_alternative_list_type_hint" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_alternative_list_type_hint">test_alternative_list_type_hint</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_any" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_any">test_any</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_any_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_any_type">test_any_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_args_kwargs" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_args_kwargs">test_args_kwargs</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_args_kwargs_different_types" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_args_kwargs_different_types">test_args_kwargs_different_types</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_args_kwargs_no_type_hint" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_args_kwargs_no_type_hint">test_args_kwargs_no_type_hint</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_args_kwargs_wrong_type_hint" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_args_kwargs_wrong_type_hint">test_args_kwargs_wrong_type_hint</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_binary_io" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_binary_io">test_binary_io</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_binary_io_fail" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_binary_io_fail">test_binary_io_fail</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_binary_io_real_file" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_binary_io_real_file">test_binary_io_real_file</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_bytearray_bytes" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_bytearray_bytes">test_bytearray_bytes</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable">test_callable</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_bad_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_bad_type">test_callable_bad_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_bound_method" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_bound_method">test_callable_bound_method</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_builtin" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_builtin">test_callable_builtin</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_class" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_class">test_callable_class</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_defaults" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_defaults">test_callable_defaults</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_exact_arg_count" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_exact_arg_count">test_callable_exact_arg_count</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_mandatory_kwonlyargs" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_mandatory_kwonlyargs">test_callable_mandatory_kwonlyargs</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_no_args" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_no_args">test_callable_no_args</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_nonmember" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_nonmember">test_callable_nonmember</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_plain" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_plain">test_callable_plain</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_too_few_arguments" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_too_few_arguments">test_callable_too_few_arguments</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_with_union_return" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_with_union_return">test_callable_with_union_return</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_without_args_correct_with_lambdas" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_without_args_correct_with_lambdas">test_callable_without_args_correct_with_lambdas</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_without_args_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_without_args_corrected">test_callable_without_args_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_without_type_args" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_callable_without_type_args">test_callable_without_type_args</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class">test_class</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class_any" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class_any">test_class_any</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class_bad_subclass" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class_bad_subclass">test_class_bad_subclass</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class_decorator" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class_decorator">test_class_decorator</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class_no_type_vars" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class_no_type_vars">test_class_no_type_vars</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class_not_a_class" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_class_not_a_class">test_class_not_a_class</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_collection" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_collection">test_collection</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_complex" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_complex">test_complex</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_container" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_container">test_container</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_container_no_type_args" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_container_no_type_args">test_container_no_type_args</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_coroutine_correct_return_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_coroutine_correct_return_type">test_coroutine_correct_return_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_coroutine_wrong_return_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_coroutine_wrong_return_type">test_coroutine_wrong_return_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_date_datetime" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_date_datetime">test_date_datetime</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_dict" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_dict">test_dict</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_dict_bad_key_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_dict_bad_key_type">test_dict_bad_key_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_dict_bad_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_dict_bad_type">test_dict_bad_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_dict_bad_value_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_dict_bad_value_type">test_dict_bad_value_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_double_pedantic" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_double_pedantic">test_double_pedantic</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_ellipsis_in_callable_1" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_ellipsis_in_callable_1">test_ellipsis_in_callable_1</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_ellipsis_in_callable_2" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_ellipsis_in_callable_2">test_ellipsis_in_callable_2</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_ellipsis_in_callable_3" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_ellipsis_in_callable_3">test_ellipsis_in_callable_3</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_empty_tuple" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_empty_tuple">test_empty_tuple</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_enum" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_enum">test_enum</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_enum_1" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_enum_1">test_enum_1</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_enum_1_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_enum_1_corrected">test_enum_1_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_enum_aggregate" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_enum_aggregate">test_enum_aggregate</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_float" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_float">test_float</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_forward_ref" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_forward_ref">test_forward_ref</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator">test_generator</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator_bad_return" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator_bad_return">test_generator_bad_return</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator_bad_send" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator_bad_send">test_generator_bad_send</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator_bad_yield" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator_bad_yield">test_generator_bad_yield</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator_no_type_args" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator_no_type_args">test_generator_no_type_args</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator_simple" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generator_simple">test_generator_simple</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generic" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_generic">test_generic</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_implicit_default_none" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_implicit_default_none">test_implicit_default_none</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_inheritance_1" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_inheritance_1">test_inheritance_1</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_inheritance_2" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_inheritance_2">test_inheritance_2</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_inherited_class_method" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_inherited_class_method">test_inherited_class_method</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_1" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_1">test_instance_method_1</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_2" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_2">test_instance_method_2</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_2_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_2_corrected">test_instance_method_2_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_3_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_3_corrected">test_instance_method_3_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_5" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_5">test_instance_method_5</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_int_is_not_float" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_int_is_not_float">test_instance_method_int_is_not_float</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_no_kwargs" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_instance_method_no_kwargs">test_instance_method_no_kwargs</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_is_subtype_tuple" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_is_subtype_tuple">test_is_subtype_tuple</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_is_subtype_tuple_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_is_subtype_tuple_corrected">test_is_subtype_tuple_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterable" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterable">test_iterable</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterable_advanced" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterable_advanced">test_iterable_advanced</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterable_advanced_no_type_args" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterable_advanced_no_type_args">test_iterable_advanced_no_type_args</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterable_no_type_args" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterable_no_type_args">test_iterable_no_type_args</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterator" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterator">test_iterator</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterator_no_type_args" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_iterator_no_type_args">test_iterator_no_type_args</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_kwargs" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_kwargs">test_kwargs</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_kwargs_fail" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_kwargs_fail">test_kwargs_fail</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_1" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_1">test_lambda_1</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_3" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_3">test_lambda_3</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_4_almost_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_4_almost_corrected">test_lambda_4_almost_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_4_almost_corrected_2" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_4_almost_corrected_2">test_lambda_4_almost_corrected_2</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_5" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_5">test_lambda_5</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_corrected">test_lambda_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_int_is_not_float" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_lambda_int_is_not_float">test_lambda_int_is_not_float</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list">test_list</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list_bad_element" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list_bad_element">test_list_bad_element</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list_bad_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list_bad_type">test_list_bad_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list_of_new_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list_of_new_type">test_list_of_new_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list_without_args" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list_without_args">test_list_without_args</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list_without_args_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_list_without_args_corrected">test_list_without_args_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_literal" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_literal">test_literal</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_literal_illegal_value" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_literal_illegal_value">test_literal_illegal_value</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_literal_union" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_literal_union">test_literal_union</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_local_class" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_local_class">test_local_class</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_local_class_async" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_local_class_async">test_local_class_async</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_marco" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_marco">test_marco</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_mismatching_default_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_mismatching_default_type">test_mismatching_default_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_1" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_1">test_missing_type_hint_1</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_1_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_1_corrected">test_missing_type_hint_1_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_2" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_2">test_missing_type_hint_2</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_2_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_2_corrected">test_missing_type_hint_2_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_3" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_3">test_missing_type_hint_3</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_3_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_missing_type_hint_3_corrected">test_missing_type_hint_3_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_namedtuple" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_namedtuple">test_namedtuple</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_namedtuple_huge_type_mismatch" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_namedtuple_huge_type_mismatch">test_namedtuple_huge_type_mismatch</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_namedtuple_key_mismatch" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_namedtuple_key_mismatch">test_namedtuple_key_mismatch</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_namedtuple_type_mismatch" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_namedtuple_type_mismatch">test_namedtuple_type_mismatch</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_namedtuple_wrong_field_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_namedtuple_wrong_field_type">test_namedtuple_wrong_field_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_1" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_1">test_nested_type_hints_1</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_1_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_1_corrected">test_nested_type_hints_1_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_2" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_2">test_nested_type_hints_2</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_2_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_2_corrected">test_nested_type_hints_2_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_3" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_3">test_nested_type_hints_3</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_3_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_3_corrected">test_nested_type_hints_3_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_4" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_4">test_nested_type_hints_4</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_5" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_5">test_nested_type_hints_5</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_5_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_5_corrected">test_nested_type_hints_5_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_nested_type_hints_corrected">test_nested_type_hints_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_new_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_new_type">test_new_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_newtype" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_newtype">test_newtype</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_no_kwargs" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_no_kwargs">test_no_kwargs</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_none_1" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_none_1">test_none_1</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_none_2" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_none_2">test_none_2</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_none_3" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_none_3">test_none_3</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_none_4" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_none_4">test_none_4</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_none_5" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_none_5">test_none_5</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_noreturn" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_noreturn">test_noreturn</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_1" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_1">test_optional_args_1</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_2" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_2">test_optional_args_2</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_3" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_3">test_optional_args_3</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_3_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_3_corrected">test_optional_args_3_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_4" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_4">test_optional_args_4</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_5" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_5">test_optional_args_5</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_6" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_optional_args_6">test_optional_args_6</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic">test_pedantic</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic_always" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic_always">test_pedantic_always</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic_arguments_fail" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic_arguments_fail">test_pedantic_arguments_fail</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic_on_class" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic_on_class">test_pedantic_on_class</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic_return_type_fail" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic_return_type_fail">test_pedantic_return_type_fail</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic_return_type_var_fail" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_pedantic_return_type_var_fail">test_pedantic_return_type_var_fail</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_return_generator" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_return_generator">test_return_generator</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_return_type_none" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_return_type_none">test_return_type_none</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sequence" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sequence">test_sequence</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sequence_bad_element" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sequence_bad_element">test_sequence_bad_element</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sequence_bad_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sequence_bad_type">test_sequence_bad_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sequence_no_type_args" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sequence_no_type_args">test_sequence_no_type_args</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_set" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_set">test_set</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_set_bad_element" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_set_bad_element">test_set_bad_element</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_set_bad_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_set_bad_type">test_set_bad_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_set_no_type_args" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_set_no_type_args">test_set_no_type_args</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_dict" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_dict">test_sloppy_types_dict</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_dict_almost_corrected_no_type_args" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_dict_almost_corrected_no_type_args">test_sloppy_types_dict_almost_corrected_no_type_args</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_dict_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_dict_corrected">test_sloppy_types_dict_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_frozenset" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_frozenset">test_sloppy_types_frozenset</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_frozenset_almost_corrected_no_type_args" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_frozenset_almost_corrected_no_type_args">test_sloppy_types_frozenset_almost_corrected_no_type_args</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_frozenset_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_frozenset_corrected">test_sloppy_types_frozenset_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_list" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_list">test_sloppy_types_list</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_list_almost_corrected_no_type_args" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_list_almost_corrected_no_type_args">test_sloppy_types_list_almost_corrected_no_type_args</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_list_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_list_corrected">test_sloppy_types_list_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_set" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_set">test_sloppy_types_set</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_set_almost_corrected_to_type_args" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_set_almost_corrected_to_type_args">test_sloppy_types_set_almost_corrected_to_type_args</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_set_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_set_corrected">test_sloppy_types_set_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_tuple" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_tuple">test_sloppy_types_tuple</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_tuple_almost_corrected_no_type_args" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_tuple_almost_corrected_no_type_args">test_sloppy_types_tuple_almost_corrected_no_type_args</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_tuple_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_sloppy_types_tuple_corrected">test_sloppy_types_tuple_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_text_io" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_text_io">test_text_io</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_text_io_fail" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_text_io_fail">test_text_io_fail</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_text_io_real_file" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_text_io_real_file">test_text_io_real_file</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple">test_tuple</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_bad_element" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_bad_element">test_tuple_bad_element</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_bad_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_bad_type">test_tuple_bad_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_ellipsis_bad_element" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_ellipsis_bad_element">test_tuple_ellipsis_bad_element</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_no_type_args" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_no_type_args">test_tuple_no_type_args</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_too_few_elements" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_too_few_elements">test_tuple_too_few_elements</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_too_many_elements" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_too_many_elements">test_tuple_too_many_elements</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_without_args_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_without_args_corrected">test_tuple_without_args_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_without_type_args" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_tuple_without_type_args">test_tuple_without_type_args</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_list_but_got_tuple" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_list_but_got_tuple">test_type_list_but_got_tuple</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_list_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_list_corrected">test_type_list_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var">test_type_var</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_bound_fail" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_bound_fail">test_type_var_bound_fail</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_constraints" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_constraints">test_type_var_constraints</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_constraints_fail_typing_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_constraints_fail_typing_type">test_type_var_constraints_fail_typing_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_contravariant" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_contravariant">test_type_var_contravariant</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_contravariant_fail" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_contravariant_fail">test_type_var_contravariant_fail</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_covariant" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_covariant">test_type_var_covariant</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_covariant_fail" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_covariant_fail">test_type_var_covariant_fail</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_forward_ref_bound" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_forward_ref_bound">test_type_var_forward_ref_bound</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_invariant_fail" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_invariant_fail">test_type_var_invariant_fail</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_wrong" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_wrong">test_type_var_wrong</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_wrong_sequence" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_type_var_wrong_sequence">test_type_var_wrong_sequence</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_typevar_bound" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_typevar_bound">test_typevar_bound</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_typevar_constraints_fail" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_typevar_constraints_fail">test_typevar_constraints_fail</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_union" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_union">test_union</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_union_fail" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_union_fail">test_union_fail</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_union_typing_type" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_union_typing_type">test_union_typing_type</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_varargs" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_varargs">test_varargs</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_varargs_fail" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_varargs_fail">test_varargs_fail</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrapped_function" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrapped_function">test_wrapped_function</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrapped_generator_no_return_type_annotation" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrapped_generator_no_return_type_annotation">test_wrapped_generator_no_return_type_annotation</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_1" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_1">test_wrong_type_hint_1</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_1_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_1_corrected">test_wrong_type_hint_1_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_2" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_2">test_wrong_type_hint_2</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_2_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_2_corrected">test_wrong_type_hint_2_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_3" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_3">test_wrong_type_hint_3</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_4" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_4">test_wrong_type_hint_4</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_4_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_4_corrected">test_wrong_type_hint_4_corrected</a></code></li>
<li><code><a title="pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_corrected" href="#pedantic.tests.tests_pedantic.TestDecoratorRequireKwargsAndTypeCheck.test_wrong_type_hint_corrected">test_wrong_type_hint_corrected</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>